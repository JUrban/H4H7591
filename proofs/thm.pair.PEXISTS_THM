Hi Geoff, go and have some cold beer while I am trying to solve this very hard problem!
% remaining time: 149 next slice time: 5
dis+11_7_3 on thm.pair
% Refutation found. Thanks to Tanya!
% SZS status Theorem for thm.pair
% SZS output start Proof for thm.pair
fof(f16000,plain,(
  $false),
  inference(sat_splitting_refutation,[],[f148,f209,f207,f15712,f6477,f650,f648,f147,f208,f211,f6390,f7940,f8435,f8525,f6374,f6370,f6352,f1158,f1154,f9240,f774,f772,f15921,f4275,f4276,f2189,f2273,f1139,f4344,f6373])).
fof(f6373,plain,(
  ( ! [X18,X16] : (s(bool,X18) = s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),X16))) | s(bool,'T_0') = s(bool,X18)) ) | $spl130),
  inference(cnf_transformation,[],[f6373_D])).
fof(f6373_D,plain,(
  ( ! [X18,X16] : (s(bool,X18) = s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),X16))) | s(bool,'T_0') = s(bool,X18)) ) <=> ~$spl130),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl130])])).
fof(f4344,plain,(
  ( ! [X23,X22] : (s(bool,X23) = s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),X22))) | s(bool,'T_0') = s(bool,X23)) ) | $spl88),
  inference(subsumption_resolution,[],[f4304,f151])).
fof(f151,plain,(
  ~p(s(bool,'F_0'))),
  inference(cnf_transformation,[],[f41])).
fof(f41,plain,(
  ~p(s(bool,'F_0'))),
  inference(flattening,[],[f2])).
fof(f2,axiom,(
  ~p(s(bool,'F_0'))),
  file('thm.pair.PEXISTS_THM',aHL_FALSITY)).
fof(f4304,plain,(
  ( ! [X23,X22] : (p(s(bool,'F_0')) | s(bool,X23) = s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),X22))) | s(bool,'T_0') = s(bool,X23)) ) | $spl88),
  inference(superposition,[],[f240,f4276])).
fof(f240,plain,(
  ( ! [X2,X1] : (p(s(bool,X1)) | s(bool,X1) = s(bool,X2) | s(bool,'T_0') = s(bool,X2)) )),
  inference(resolution,[],[f177,f154])).
fof(f154,plain,(
  ( ! [X0] : (~p(s(bool,X0)) | s(bool,'T_0') = s(bool,X0)) )),
  inference(cnf_transformation,[],[f113])).
fof(f113,plain,(
  ! [X0] : ((s(bool,'T_0') != s(bool,X0) | p(s(bool,X0))) & (~p(s(bool,X0)) | s(bool,'T_0') = s(bool,X0)))),
  inference(nnf_transformation,[],[f42])).
fof(f42,plain,(
  ! [X0] : (s(bool,'T_0') = s(bool,X0) <=> p(s(bool,X0)))),
  inference(rectify,[],[f32])).
fof(f32,axiom,(
  ! [X11] : (s(bool,'T_0') = s(bool,X11) <=> p(s(bool,X11)))),
  file('thm.pair.PEXISTS_THM','thm.bool.EQ_CLAUSES|split|0')).
fof(f177,plain,(
  ( ! [X0,X1] : (p(s(bool,X1)) | p(s(bool,X0)) | s(bool,X0) = s(bool,X1)) )),
  inference(cnf_transformation,[],[f107])).
fof(f107,plain,(
  ! [X0,X1] : ((p(s(bool,X0)) & ~p(s(bool,X1))) | (p(s(bool,X1)) & ~p(s(bool,X0))) | s(bool,X0) = s(bool,X1))),
  inference(flattening,[],[f106])).
fof(f106,plain,(
  ! [X0,X1] : ((p(s(bool,X0)) & ~p(s(bool,X1))) | ((p(s(bool,X1)) & ~p(s(bool,X0))) | s(bool,X0) = s(bool,X1)))),
  inference(ennf_transformation,[],[f61])).
fof(f61,plain,(
  ! [X0,X1] : ((p(s(bool,X0)) => p(s(bool,X1))) => ((p(s(bool,X1)) => p(s(bool,X0))) => s(bool,X0) = s(bool,X1)))),
  inference(rectify,[],[f20])).
fof(f20,axiom,(
  ! [X22,X23] : ((p(s(bool,X22)) => p(s(bool,X23))) => ((p(s(bool,X23)) => p(s(bool,X22))) => s(bool,X22) = s(bool,X23)))),
  file('thm.pair.PEXISTS_THM','thm.bool.IMP_ANTISYM_AX')).
fof(f1139,plain,(
  ( ! [X77] : (~p(s(bool,X77))) ) | $spl22),
  inference(cnf_transformation,[],[f1139_D])).
fof(f1139_D,plain,(
  ( ! [X77] : (~p(s(bool,X77))) ) <=> ~$spl22),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl22])])).
fof(f2273,plain,(
  ( ! [X0] : (~p(s(bool,X0))) ) | $spl50),
  inference(superposition,[],[f151,f2189])).
fof(f2189,plain,(
  ( ! [X12] : (s(bool,'F_0') = s(bool,X12)) ) | $spl50),
  inference(cnf_transformation,[],[f2189_D])).
fof(f2189_D,plain,(
  ( ! [X12] : (s(bool,'F_0') = s(bool,X12)) ) <=> ~$spl50),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl50])])).
fof(f4276,plain,(
  ( ! [X12] : (s(bool,'F_0') = s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),X12)))) ) | $spl88),
  inference(cnf_transformation,[],[f4276_D])).
fof(f4276_D,plain,(
  ( ! [X12] : (s(bool,'F_0') = s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),X12)))) ) <=> ~$spl88),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl88])])).
fof(f4275,plain,(
  ( ! [X12,X13] : (s(bool,'F_0') = s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),X12))) | s(bool,'F_0') = s(bool,X13)) ) | $spl3),
  inference(subsumption_resolution,[],[f4270,f152])).
fof(f152,plain,(
  ( ! [X0] : (s(bool,'F_0') = s(bool,X0) | s(bool,'T_0') = s(bool,X0)) )),
  inference(cnf_transformation,[],[f3])).
fof(f3,axiom,(
  ! [X0] : (s(bool,'T_0') = s(bool,X0) | s(bool,'F_0') = s(bool,X0))),
  file('thm.pair.PEXISTS_THM',aHL_BOOL_CASES)).
fof(f4270,plain,(
  ( ! [X12,X13] : (s(bool,'T_0') != s(bool,X13) | s(bool,'F_0') = s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),X12))) | s(bool,'F_0') = s(bool,X13)) ) | $spl3),
  inference(superposition,[],[f4138,f288])).
fof(f288,plain,(
  ( ! [X10,X11] : (s(bool,X10) = s(bool,X11) | s(bool,'F_0') = s(bool,X11) | s(bool,'F_0') = s(bool,X10)) )),
  inference(resolution,[],[f253,f158])).
fof(f158,plain,(
  ( ! [X0] : (p(s(bool,X0)) | s(bool,'F_0') = s(bool,X0)) )),
  inference(cnf_transformation,[],[f115])).
fof(f115,plain,(
  ! [X0] : ((s(bool,'F_0') != s(bool,X0) | ~p(s(bool,X0))) & (p(s(bool,X0)) | s(bool,'F_0') = s(bool,X0)))),
  inference(nnf_transformation,[],[f45])).
fof(f45,plain,(
  ! [X0] : (s(bool,'F_0') = s(bool,X0) <=> ~p(s(bool,X0)))),
  inference(flattening,[],[f44])).
fof(f44,plain,(
  ! [X0] : (s(bool,'F_0') = s(bool,X0) <=> ~p(s(bool,X0)))),
  inference(rectify,[],[f29])).
fof(f29,axiom,(
  ! [X11] : (s(bool,'F_0') = s(bool,X11) <=> ~p(s(bool,X11)))),
  file('thm.pair.PEXISTS_THM','thm.bool.EQ_CLAUSES|split|3')).
fof(f253,plain,(
  ( ! [X8,X7] : (~p(s(bool,X7)) | s(bool,X7) = s(bool,X8) | s(bool,'F_0') = s(bool,X8)) )),
  inference(resolution,[],[f180,f158])).
fof(f180,plain,(
  ( ! [X0,X1] : (~p(s(bool,X1)) | ~p(s(bool,X0)) | s(bool,X0) = s(bool,X1)) )),
  inference(cnf_transformation,[],[f107])).
fof(f4138,plain,(
  ( ! [X25] : (s(bool,'T_0') != s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),X25)))) ) | $spl3),
  inference(superposition,[],[f1451,f197])).
fof(f197,plain,(
  ( ! [X4,X2,X0,X3,X1] : (s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),X4))) = s(X0,happ(s(fun('type.pair.prod'(X1,X2),X0),'const.pair.UNCURRY_1'(s(fun(X1,fun(X2,X0)),X3))),s('type.pair.prod'(X1,X2),X4)))) )),
  inference(cnf_transformation,[],[f87])).
fof(f87,plain,(
  ! [X0,X1,X2,X3,X4] : s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),X4))) = s(X0,happ(s(fun('type.pair.prod'(X1,X2),X0),'const.pair.UNCURRY_1'(s(fun(X1,fun(X2,X0)),X3))),s('type.pair.prod'(X1,X2),X4)))),
  inference(flattening,[],[f86])).
fof(f86,plain,(
  ! [X0,X1,X2] : ! [X3,X4] : s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),X4))) = s(X0,happ(s(fun('type.pair.prod'(X1,X2),X0),'const.pair.UNCURRY_1'(s(fun(X1,fun(X2,X0)),X3))),s('type.pair.prod'(X1,X2),X4)))),
  inference(rectify,[],[f8])).
fof(f8,axiom,(
  ! [X12,X6,X7] : ! [X13,X14] : s(X12,'const.pair.UNCURRY_2'(s(fun(X6,fun(X7,X12)),X13),s('type.pair.prod'(X6,X7),X14))) = s(X12,happ(s(fun('type.pair.prod'(X6,X7),X12),'const.pair.UNCURRY_1'(s(fun(X6,fun(X7,X12)),X13))),s('type.pair.prod'(X6,X7),X14)))),
  file('thm.pair.PEXISTS_THM','ARITY_1_2_const.pair.UNCURRY')).
fof(f1451,plain,(
  ( ! [X0] : (s(bool,'T_0') != s(bool,happ(s(fun('type.pair.prod'(sK0,sK1),bool),'const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2))),s('type.pair.prod'(sK0,sK1),X0)))) ) | $spl3),
  inference(subsumption_resolution,[],[f1439,f151])).
fof(f1439,plain,(
  ( ! [X0] : (p(s(bool,'F_0')) | s(bool,'T_0') != s(bool,happ(s(fun('type.pair.prod'(sK0,sK1),bool),'const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2))),s('type.pair.prod'(sK0,sK1),X0)))) ) | $spl3),
  inference(superposition,[],[f307,f259])).
fof(f259,plain,(
  s(bool,'F_0') = s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(sK0,sK1),bool),'const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2))))) | $spl3),
  inference(resolution,[],[f209,f158])).
fof(f307,plain,(
  ( ! [X17,X15,X16] : (p(s(bool,'|dollar|exists_1'(s(fun(X15,bool),X16)))) | s(bool,'T_0') != s(bool,happ(s(fun(X15,bool),X16),s(X15,X17)))) )),
  inference(resolution,[],[f170,f153])).
fof(f153,plain,(
  ( ! [X0] : (p(s(bool,X0)) | s(bool,'T_0') != s(bool,X0)) )),
  inference(cnf_transformation,[],[f113])).
fof(f170,plain,(
  ( ! [X2,X0,X1] : (~p(s(bool,happ(s(fun(X0,bool),X1),s(X0,X2)))) | p(s(bool,'|dollar|exists_1'(s(fun(X0,bool),X1))))) )),
  inference(cnf_transformation,[],[f124])).
fof(f124,plain,(
  ! [X0,X1] : ((~p(s(bool,'|dollar|exists_1'(s(fun(X0,bool),X1)))) | p(s(bool,happ(s(fun(X0,bool),X1),s(X0,sK7(X1,X0)))))) & (! [X2] : ~p(s(bool,happ(s(fun(X0,bool),X1),s(X0,X2)))) | p(s(bool,'|dollar|exists_1'(s(fun(X0,bool),X1))))))),
  inference(skolemisation,[status(esa),new_symbols(skolem,[sK7])],[f123])).
fof(f123,plain,(
  ! [X0,X1] : ((~p(s(bool,'|dollar|exists_1'(s(fun(X0,bool),X1)))) | ? [X3] : p(s(bool,happ(s(fun(X0,bool),X1),s(X0,X3))))) & (! [X2] : ~p(s(bool,happ(s(fun(X0,bool),X1),s(X0,X2)))) | p(s(bool,'|dollar|exists_1'(s(fun(X0,bool),X1))))))),
  inference(rectify,[],[f122])).
fof(f122,plain,(
  ! [X0,X1] : ((~p(s(bool,'|dollar|exists_1'(s(fun(X0,bool),X1)))) | ? [X2] : p(s(bool,happ(s(fun(X0,bool),X1),s(X0,X2))))) & (! [X2] : ~p(s(bool,happ(s(fun(X0,bool),X1),s(X0,X2)))) | p(s(bool,'|dollar|exists_1'(s(fun(X0,bool),X1))))))),
  inference(nnf_transformation,[],[f55])).
fof(f55,plain,(
  ! [X0,X1] : (p(s(bool,'|dollar|exists_1'(s(fun(X0,bool),X1)))) <=> ? [X2] : p(s(bool,happ(s(fun(X0,bool),X1),s(X0,X2)))))),
  inference(flattening,[],[f54])).
fof(f54,plain,(
  ! [X0] : ! [X1] : (p(s(bool,'|dollar|exists_1'(s(fun(X0,bool),X1)))) <=> ? [X2] : p(s(bool,happ(s(fun(X0,bool),X1),s(X0,X2)))))),
  inference(rectify,[],[f18])).
fof(f18,axiom,(
  ! [X6] : ! [X15] : (p(s(bool,'|dollar|exists_1'(s(fun(X6,bool),X15)))) <=> ? [X9] : p(s(bool,happ(s(fun(X6,bool),X15),s(X6,X9)))))),
  file('thm.pair.PEXISTS_THM','thm.bool.EXISTS_THM')).
fof(f15921,plain,(
  $false | $spl22),
  inference(resolution,[],[f1139,f149])).
fof(f149,plain,(
  p(s(bool,'T_0'))),
  inference(cnf_transformation,[],[f1])).
fof(f1,axiom,(
  p(s(bool,'T_0'))),
  file('thm.pair.PEXISTS_THM',aHL_TRUTH)).
fof(f772,plain,(
  ( ! [X6,X7] : (~p(s(bool,'|dollar|exists_1'(s(fun(X6,bool),X7)))) | s(bool,'T_0') = s(bool,happ(s(fun(X6,bool),X7),s(X6,sK7(X7,X6))))) ) | $spl18),
  inference(cnf_transformation,[],[f772_D])).
fof(f772_D,plain,(
  ( ! [X6,X7] : (~p(s(bool,'|dollar|exists_1'(s(fun(X6,bool),X7)))) | s(bool,'T_0') = s(bool,happ(s(fun(X6,bool),X7),s(X6,sK7(X7,X6))))) ) <=> ~$spl18),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl18])])).
fof(f774,plain,(
  ( ! [X12,X13] : (~p(s(bool,'|dollar|exists_1'(s(fun(X12,bool),X13)))) | s(bool,'T_0') = s(bool,happ(s(fun(X12,bool),X13),s(X12,sK7(X13,X12))))) )),
  inference(subsumption_resolution,[],[f770,f151])).
fof(f770,plain,(
  ( ! [X12,X13] : (p(s(bool,'F_0')) | ~p(s(bool,'|dollar|exists_1'(s(fun(X12,bool),X13)))) | s(bool,'T_0') = s(bool,happ(s(fun(X12,bool),X13),s(X12,sK7(X13,X12))))) )),
  inference(superposition,[],[f169,f152])).
fof(f169,plain,(
  ( ! [X0,X1] : (p(s(bool,happ(s(fun(X0,bool),X1),s(X0,sK7(X1,X0))))) | ~p(s(bool,'|dollar|exists_1'(s(fun(X0,bool),X1))))) )),
  inference(cnf_transformation,[],[f124])).
fof(f9240,plain,(
  ( ! [X168] : (~p(s(bool,X168))) ) | $spl128),
  inference(subsumption_resolution,[],[f9003,f157])).
fof(f157,plain,(
  ( ! [X0] : (s(bool,'F_0') != s(bool,X0) | ~p(s(bool,X0))) )),
  inference(cnf_transformation,[],[f115])).
fof(f9003,plain,(
  ( ! [X168] : (~p(s(bool,X168)) | s(bool,'F_0') = s(bool,X168)) ) | $spl128),
  inference(superposition,[],[f151,f6370])).
fof(f1154,plain,(
  ( ! [X50,X48] : (s(bool,'T_0') != s(bool,X48) | s(bool,'F_0') = s(bool,X50) | s(bool,X48) = s(bool,X50)) ) | $spl24),
  inference(cnf_transformation,[],[f1154_D])).
fof(f1154_D,plain,(
  ( ! [X50,X48] : (s(bool,'T_0') != s(bool,X48) | s(bool,'F_0') = s(bool,X50) | s(bool,X48) = s(bool,X50)) ) <=> ~$spl24),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl24])])).
fof(f1158,plain,(
  ( ! [X2,X1] : (s(bool,'T_0') != s(bool,X1) | s(bool,X1) = s(bool,X2) | s(bool,'F_0') = s(bool,X2)) )),
  inference(subsumption_resolution,[],[f950,f151])).
fof(f950,plain,(
  ( ! [X2,X1] : (p(s(bool,'F_0')) | s(bool,'T_0') != s(bool,X1) | s(bool,X1) = s(bool,X2) | s(bool,'F_0') = s(bool,X2)) )),
  inference(superposition,[],[f153,f288])).
fof(f6352,plain,(
  $false | ($spl3 | $spl14)),
  inference(trivial_inequality_removal,[],[f6333])).
fof(f6333,plain,(
  s(bool,'T_0') != s(bool,'T_0') | ($spl3 | $spl14)),
  inference(superposition,[],[f6201,f648])).
fof(f6201,plain,(
  ( ! [X92,X93] : (s(bool,'T_0') != s(bool,happ(s(fun(sK1,bool),happ(s(fun(sK0,fun(sK1,bool)),sK2),s(sK0,X92))),s(sK1,X93)))) ) | $spl3),
  inference(superposition,[],[f4138,f202])).
fof(f202,plain,(
  ( ! [X4,X2,X0,X5,X3,X1] : (s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X3),s(X1,X4))),s(X2,X5))) = s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),'const.pair.,_2'(s(X1,X4),s(X2,X5)))))) )),
  inference(cnf_transformation,[],[f95])).
fof(f95,plain,(
  ! [X0,X1,X2,X3,X4,X5] : s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X3),s(X1,X4))),s(X2,X5))) = s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),'const.pair.,_2'(s(X1,X4),s(X2,X5)))))),
  inference(flattening,[],[f94])).
fof(f94,plain,(
  ! [X0,X1,X2] : ! [X3,X4,X5] : s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X3),s(X1,X4))),s(X2,X5))) = s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),'const.pair.,_2'(s(X1,X4),s(X2,X5)))))),
  inference(rectify,[],[f33])).
fof(f33,axiom,(
  ! [X12,X6,X7] : ! [X15,X9,X10] : s(X12,happ(s(fun(X7,X12),happ(s(fun(X6,fun(X7,X12)),X15),s(X6,X9))),s(X7,X10))) = s(X12,'const.pair.UNCURRY_2'(s(fun(X6,fun(X7,X12)),X15),s('type.pair.prod'(X6,X7),'const.pair.,_2'(s(X6,X9),s(X7,X10)))))),
  file('thm.pair.PEXISTS_THM','thm.pair.UNCURRY_DEF')).
fof(f6370,plain,(
  ( ! [X8,X7] : (s(bool,'F_0') = s(bool,X7) | s(bool,X7) = s(bool,X8)) ) | $spl128),
  inference(cnf_transformation,[],[f6370_D])).
fof(f6370_D,plain,(
  ( ! [X8,X7] : (s(bool,'F_0') = s(bool,X7) | s(bool,X7) = s(bool,X8)) ) <=> ~$spl128),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl128])])).
fof(f6374,plain,(
  ( ! [X61] : (s(bool,'T_0') != s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),X61)))) ) | $spl132),
  inference(cnf_transformation,[],[f6374_D])).
fof(f6374_D,plain,(
  ( ! [X61] : (s(bool,'T_0') != s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),X61)))) ) <=> ~$spl132),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl132])])).
fof(f8525,plain,(
  ( ! [X103,X102,X104] : (s(bool,'T_0') != s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),X103))) | s(bool,'F_0') = s(bool,X104) | s(bool,X102) = s(bool,X104)) ) | ($spl24 | $spl130)),
  inference(subsumption_resolution,[],[f7514,f1154])).
fof(f7514,plain,(
  ( ! [X103,X102,X104] : (s(bool,'T_0') != s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),X103))) | s(bool,'F_0') = s(bool,X104) | s(bool,X102) = s(bool,X104) | s(bool,'T_0') = s(bool,X102)) ) | ($spl24 | $spl130)),
  inference(superposition,[],[f1154,f6373])).
fof(f8435,plain,(
  ( ! [X17] : (~p(s(bool,X17))) ) | ($spl18 | $spl132 | $spl146)),
  inference(subsumption_resolution,[],[f8434,f6374])).
fof(f8434,plain,(
  ( ! [X17] : (s(bool,'T_0') = s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),sK7('const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2)),'type.pair.prod'(sK0,sK1))))) | ~p(s(bool,X17))) ) | ($spl18 | $spl146)),
  inference(forward_demodulation,[],[f8433,f197])).
fof(f8433,plain,(
  ( ! [X17] : (~p(s(bool,X17)) | s(bool,'T_0') = s(bool,happ(s(fun('type.pair.prod'(sK0,sK1),bool),'const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2))),s('type.pair.prod'(sK0,sK1),sK7('const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2)),'type.pair.prod'(sK0,sK1)))))) ) | ($spl18 | $spl146)),
  inference(subsumption_resolution,[],[f8251,f157])).
fof(f8251,plain,(
  ( ! [X17] : (~p(s(bool,X17)) | s(bool,'T_0') = s(bool,happ(s(fun('type.pair.prod'(sK0,sK1),bool),'const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2))),s('type.pair.prod'(sK0,sK1),sK7('const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2)),'type.pair.prod'(sK0,sK1))))) | s(bool,'F_0') = s(bool,X17)) ) | ($spl18 | $spl146)),
  inference(superposition,[],[f772,f7940])).
fof(f7940,plain,(
  ( ! [X13] : (s(bool,X13) = s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(sK0,sK1),bool),'const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2))))) | s(bool,'F_0') = s(bool,X13)) ) | $spl146),
  inference(cnf_transformation,[],[f7940_D])).
fof(f7940_D,plain,(
  ( ! [X13] : (s(bool,X13) = s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(sK0,sK1),bool),'const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2))))) | s(bool,'F_0') = s(bool,X13)) ) <=> ~$spl146),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl146])])).
fof(f6390,plain,(
  ( ! [X4] : (s(bool,X4) = s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(sK0,sK1),bool),'const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2))))) | s(bool,'F_0') = s(bool,X4)) ) | $spl2),
  inference(resolution,[],[f208,f253])).
fof(f211,plain,(
  p(s(bool,happ(s(fun(sK1,bool),happ(s(fun(sK0,fun(sK1,bool)),sK2),s(sK0,sK3))),s(sK1,sK4)))) | $spl4),
  inference(cnf_transformation,[],[f211_D])).
fof(f211_D,plain,(
  p(s(bool,happ(s(fun(sK1,bool),happ(s(fun(sK0,fun(sK1,bool)),sK2),s(sK0,sK3))),s(sK1,sK4)))) <=> ~$spl4),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl4])])).
fof(f208,plain,(
  p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(sK0,sK1),bool),'const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2)))))) | $spl2),
  inference(cnf_transformation,[],[f208_D])).
fof(f208_D,plain,(
  p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(sK0,sK1),bool),'const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2)))))) <=> ~$spl2),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl2])])).
fof(f147,plain,(
  p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(sK0,sK1),bool),'const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2)))))) | p(s(bool,happ(s(fun(sK1,bool),happ(s(fun(sK0,fun(sK1,bool)),sK2),s(sK0,sK3))),s(sK1,sK4))))),
  inference(cnf_transformation,[],[f112])).
fof(f112,plain,(
  (p(s(bool,happ(s(fun(sK1,bool),happ(s(fun(sK0,fun(sK1,bool)),sK2),s(sK0,sK3))),s(sK1,sK4)))) | p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(sK0,sK1),bool),'const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2))))))) & (! [X3,X4] : ~p(s(bool,happ(s(fun(sK1,bool),happ(s(fun(sK0,fun(sK1,bool)),sK2),s(sK0,X3))),s(sK1,X4)))) | ~p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(sK0,sK1),bool),'const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2)))))))),
  inference(skolemisation,[status(esa),new_symbols(skolem,[sK0,sK1,sK2,sK3,sK4])],[f111])).
fof(f111,plain,(
  ? [X0,X1,X2] : ((? [X5,X6] : p(s(bool,happ(s(fun(X1,bool),happ(s(fun(X0,fun(X1,bool)),X2),s(X0,X5))),s(X1,X6)))) | p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(X0,X1),bool),'const.pair.UNCURRY_1'(s(fun(X0,fun(X1,bool)),X2))))))) & (! [X3,X4] : ~p(s(bool,happ(s(fun(X1,bool),happ(s(fun(X0,fun(X1,bool)),X2),s(X0,X3))),s(X1,X4)))) | ~p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(X0,X1),bool),'const.pair.UNCURRY_1'(s(fun(X0,fun(X1,bool)),X2))))))))),
  inference(rectify,[],[f110])).
fof(f110,plain,(
  ? [X0,X1,X2] : ((? [X3,X4] : p(s(bool,happ(s(fun(X1,bool),happ(s(fun(X0,fun(X1,bool)),X2),s(X0,X3))),s(X1,X4)))) | p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(X0,X1),bool),'const.pair.UNCURRY_1'(s(fun(X0,fun(X1,bool)),X2))))))) & (! [X3,X4] : ~p(s(bool,happ(s(fun(X1,bool),happ(s(fun(X0,fun(X1,bool)),X2),s(X0,X3))),s(X1,X4)))) | ~p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(X0,X1),bool),'const.pair.UNCURRY_1'(s(fun(X0,fun(X1,bool)),X2))))))))),
  inference(nnf_transformation,[],[f102])).
fof(f102,plain,(
  ? [X0,X1,X2] : (? [X3,X4] : p(s(bool,happ(s(fun(X1,bool),happ(s(fun(X0,fun(X1,bool)),X2),s(X0,X3))),s(X1,X4)))) <~> p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(X0,X1),bool),'const.pair.UNCURRY_1'(s(fun(X0,fun(X1,bool)),X2)))))))),
  inference(ennf_transformation,[],[f40])).
fof(f40,plain,(
  ~! [X0,X1,X2] : (? [X3,X4] : p(s(bool,happ(s(fun(X1,bool),happ(s(fun(X0,fun(X1,bool)),X2),s(X0,X3))),s(X1,X4)))) <=> p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(X0,X1),bool),'const.pair.UNCURRY_1'(s(fun(X0,fun(X1,bool)),X2)))))))),
  inference(flattening,[],[f39])).
fof(f39,plain,(
  ~! [X0,X1] : ! [X2] : (? [X3,X4] : p(s(bool,happ(s(fun(X1,bool),happ(s(fun(X0,fun(X1,bool)),X2),s(X0,X3))),s(X1,X4)))) <=> p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(X0,X1),bool),'const.pair.UNCURRY_1'(s(fun(X0,fun(X1,bool)),X2)))))))),
  inference(rectify,[],[f6])).
fof(f6,negated_conjecture,(
  ~! [X6,X7] : ! [X8] : (? [X9,X10] : p(s(bool,happ(s(fun(X7,bool),happ(s(fun(X6,fun(X7,bool)),X8),s(X6,X9))),s(X7,X10)))) <=> p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(X6,X7),bool),'const.pair.UNCURRY_1'(s(fun(X6,fun(X7,bool)),X8)))))))),
  inference(negated_conjecture,[],[f5])).
fof(f5,conjecture,(
  ! [X6,X7] : ! [X8] : (? [X9,X10] : p(s(bool,happ(s(fun(X7,bool),happ(s(fun(X6,fun(X7,bool)),X8),s(X6,X9))),s(X7,X10)))) <=> p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(X6,X7),bool),'const.pair.UNCURRY_1'(s(fun(X6,fun(X7,bool)),X8)))))))),
  file('thm.pair.PEXISTS_THM','thm.pair.PEXISTS_THM')).
fof(f648,plain,(
  s(bool,'T_0') = s(bool,happ(s(fun(sK1,bool),happ(s(fun(sK0,fun(sK1,bool)),sK2),s(sK0,sK3))),s(sK1,sK4))) | $spl14),
  inference(cnf_transformation,[],[f648_D])).
fof(f648_D,plain,(
  s(bool,'T_0') = s(bool,happ(s(fun(sK1,bool),happ(s(fun(sK0,fun(sK1,bool)),sK2),s(sK0,sK3))),s(sK1,sK4))) <=> ~$spl14),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl14])])).
fof(f650,plain,(
  s(bool,'T_0') = s(bool,happ(s(fun(sK1,bool),happ(s(fun(sK0,fun(sK1,bool)),sK2),s(sK0,sK3))),s(sK1,sK4))) | $spl4),
  inference(subsumption_resolution,[],[f645,f151])).
fof(f645,plain,(
  p(s(bool,'F_0')) | s(bool,'T_0') = s(bool,happ(s(fun(sK1,bool),happ(s(fun(sK0,fun(sK1,bool)),sK2),s(sK0,sK3))),s(sK1,sK4))) | $spl4),
  inference(superposition,[],[f211,f152])).
fof(f6477,plain,(
  ( ! [X2,X3] : (s(bool,X3) = s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),X2))) | s(bool,'T_0') = s(bool,X3)) ) | $spl132),
  inference(trivial_inequality_removal,[],[f6467])).
fof(f6467,plain,(
  ( ! [X2,X3] : (s(bool,'T_0') != s(bool,'T_0') | s(bool,X3) = s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),X2))) | s(bool,'T_0') = s(bool,X3)) ) | $spl132),
  inference(superposition,[],[f6374,f218])).
fof(f218,plain,(
  ( ! [X0,X1] : (s(bool,X0) = s(bool,X1) | s(bool,'T_0') = s(bool,X1) | s(bool,'T_0') = s(bool,X0)) )),
  inference(superposition,[],[f152,f152])).
fof(f15712,plain,(
  ( ! [X162] : (s(bool,'T_0') != s(bool,'const.pair.UNCURRY_2'(s(fun(sK0,fun(sK1,bool)),sK2),s('type.pair.prod'(sK0,sK1),X162)))) ) | $spl0),
  inference(superposition,[],[f6479,f198])).
fof(f198,plain,(
  ( ! [X4,X2,X0,X3,X1] : (s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),X4))) = s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X3),s(X1,'const.pair.FST_1'(s('type.pair.prod'(X1,X2),X4))))),s(X2,'const.pair.SND_1'(s('type.pair.prod'(X1,X2),X4)))))) )),
  inference(cnf_transformation,[],[f89])).
fof(f89,plain,(
  ! [X0,X1,X2,X3,X4] : s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),X4))) = s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X3),s(X1,'const.pair.FST_1'(s('type.pair.prod'(X1,X2),X4))))),s(X2,'const.pair.SND_1'(s('type.pair.prod'(X1,X2),X4)))))),
  inference(flattening,[],[f88])).
fof(f88,plain,(
  ! [X0,X1,X2] : ! [X3,X4] : s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),X4))) = s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X3),s(X1,'const.pair.FST_1'(s('type.pair.prod'(X1,X2),X4))))),s(X2,'const.pair.SND_1'(s('type.pair.prod'(X1,X2),X4)))))),
  inference(rectify,[],[f10])).
fof(f10,axiom,(
  ! [X12,X6,X7] : ! [X15,X5] : s(X12,'const.pair.UNCURRY_2'(s(fun(X6,fun(X7,X12)),X15),s('type.pair.prod'(X6,X7),X5))) = s(X12,happ(s(fun(X7,X12),happ(s(fun(X6,fun(X7,X12)),X15),s(X6,'const.pair.FST_1'(s('type.pair.prod'(X6,X7),X5))))),s(X7,'const.pair.SND_1'(s('type.pair.prod'(X6,X7),X5)))))),
  file('thm.pair.PEXISTS_THM','thm.pair.ELIM_UNCURRY')).
fof(f6479,plain,(
  ( ! [X2,X1] : (s(bool,'T_0') != s(bool,happ(s(fun(sK1,bool),happ(s(fun(sK0,fun(sK1,bool)),sK2),s(sK0,X1))),s(sK1,X2)))) ) | $spl0),
  inference(resolution,[],[f207,f153])).
fof(f207,plain,(
  ( ! [X4,X3] : (~p(s(bool,happ(s(fun(sK1,bool),happ(s(fun(sK0,fun(sK1,bool)),sK2),s(sK0,X3))),s(sK1,X4))))) ) | $spl0),
  inference(cnf_transformation,[],[f207_D])).
fof(f207_D,plain,(
  ( ! [X4,X3] : (~p(s(bool,happ(s(fun(sK1,bool),happ(s(fun(sK0,fun(sK1,bool)),sK2),s(sK0,X3))),s(sK1,X4))))) ) <=> ~$spl0),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl0])])).
fof(f209,plain,(
  ~p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(sK0,sK1),bool),'const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2)))))) | $spl3),
  inference(cnf_transformation,[],[f209_D])).
fof(f209_D,plain,(
  ~p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(sK0,sK1),bool),'const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2)))))) <=> ~$spl3),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl3])])).
fof(f148,plain,(
  ( ! [X4,X3] : (~p(s(bool,'|dollar|exists_1'(s(fun('type.pair.prod'(sK0,sK1),bool),'const.pair.UNCURRY_1'(s(fun(sK0,fun(sK1,bool)),sK2)))))) | ~p(s(bool,happ(s(fun(sK1,bool),happ(s(fun(sK0,fun(sK1,bool)),sK2),s(sK0,X3))),s(sK1,X4))))) )),
  inference(cnf_transformation,[],[f112])).
% SZS output end Proof for thm.pair
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Refutation

% Active clauses: 170
% Passive clauses: 3316
% Generated clauses: 15872
% Final active clauses: 115
% Final passive clauses: 2639
% Input formulas: 37
% Initial clauses: 59
% 
% Duplicate literals: 500
% Trivial inequalities: 228
% Fw subsumption resolutions: 1941
% Fw demodulations: 1763
% Bw demodulations: 28
% 
% Simple tautologies: 255
% Equational tautologies: 44
% Forward subsumptions: 7112
% Fw demodulations to eq. taut.: 2
% Bw demodulations to eq. taut.: 3
% 
% Binary resolution: 763
% Factoring: 4
% Forward superposition: 4402
% Backward superposition: 5627
% Self superposition: 137
% Equality factoring: 90
% Equality resolution: 17
% 
% Split clauses: 478
% Split components: 979
% SAT solver clauses: 904
% SAT solver unit clauses: 71
% SAT solver binary clauses: 210
% SAT solver learnt clauses: 4
% SAT solver learnt literals: 4
% 
% Sat splits: 478
% Sat splitting refutations: 7
% 
% TWLsolver clauses: 885
% TWLsolver calls for satisfiability: 182
% 
% Memory used [KB]: 12409
% Time elapsed: 0.490 s
% ------------------------------
% ------------------------------
% Success in time 0.482 s
