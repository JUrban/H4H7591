Hi Geoff, go and have some cold beer while I am trying to solve this very hard problem!
% remaining time: 300 next slice time: 5
dis+11_7_3 on thm.option
% (54644)Time limit reached!
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Time limit
% Termination phase: Saturation

% Active clauses: 186
% Passive clauses: 3567
% Generated clauses: 25677
% Final active clauses: 142
% Final passive clauses: 3050
% Input formulas: 11
% Initial clauses: 15
% 
% Duplicate literals: 1442
% Trivial inequalities: 357
% Fw subsumption resolutions: 2922
% Fw demodulations: 3584
% Bw demodulations: 33
% 
% Simple tautologies: 377
% Equational tautologies: 51
% Forward subsumptions: 11945
% Fw demodulations to eq. taut.: 4
% Bw demodulations to eq. taut.: 2
% 
% Binary resolution: 23
% Forward superposition: 8611
% Backward superposition: 8083
% Self superposition: 277
% Equality factoring: 143
% Equality resolution: 36
% 
% Split clauses: 709
% Split components: 1433
% SAT solver clauses: 1631
% SAT solver unit clauses: 4
% SAT solver binary clauses: 101
% 
% Sat splits: 709
% Sat splitting refutations: 4
% 
% TWLsolver clauses: 1611
% TWLsolver calls for satisfiability: 146
% 
% Memory used [KB]: 13560
% Time elapsed: 0.600 s
% ------------------------------
% ------------------------------
% remaining time: 293 next slice time: 6
lrs-11_2_cond=on:fde=unused:gs=on:nwc=3:stl=30:sdd=off:sfr=on:ssfp=100000:ssfq=1.4:smm=sco:ssnc=all_4 on thm.option
% Refutation found. Thanks to Tanya!
% SZS status Theorem for thm.option
% SZS output start Proof for thm.option
fof(f3933,plain,(
  $false),
  inference(sat_splitting_refutation,[],[f3053,f3058,f2984,f3048,f397,f435,f47,f63,f49,f66,f467,f473,f452,f453,f36,f56,f371,f375,f46,f64,f354,f367,f43,f62,f68,f69,f37,f54,f3910,f48,f65,f70,f72,f38,f53,f3082,f3084,f3805,f3807,f417,f437,f3849,f455])).
fof(f455,plain,(
  s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK2) | $spl118),
  inference(cnf_transformation,[],[f455_D])).
fof(f455_D,plain,(
  s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK2) <=> ~$spl118),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl118])])).
fof(f3849,plain,(
  s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK2) | ($spl4 | $spl1148)),
  inference(backward_demodulation,[],[f3807,f56])).
fof(f437,plain,(
  ( ! [X12,X10,X13,X11] : (s('type.option.option'(X12),'const.option.OPTION_MAP_2'(s(fun(X10,X12),X13),s('type.option.option'(X10),X11))) = s('type.option.option'(X12),'const.option.SOME_1'(s(X12,happ(s(fun(X10,X12),X13),s(X10,sK6(X11,X10)))))) | s('type.option.option'(X10),'const.option.NONE_0') = s('type.option.option'(X10),X11)) ) | $spl102),
  inference(cnf_transformation,[],[f437_D])).
fof(f437_D,plain,(
  ( ! [X12,X10,X13,X11] : (s('type.option.option'(X12),'const.option.OPTION_MAP_2'(s(fun(X10,X12),X13),s('type.option.option'(X10),X11))) = s('type.option.option'(X12),'const.option.SOME_1'(s(X12,happ(s(fun(X10,X12),X13),s(X10,sK6(X11,X10)))))) | s('type.option.option'(X10),'const.option.NONE_0') = s('type.option.option'(X10),X11)) ) <=> ~$spl102),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl102])])).
fof(f417,plain,(
  ( ! [X12,X10,X13,X11] : (s('type.option.option'(X12),'const.option.OPTION_MAP_2'(s(fun(X10,X12),X13),s('type.option.option'(X10),X11))) = s('type.option.option'(X12),'const.option.SOME_1'(s(X12,happ(s(fun(X10,X12),X13),s(X10,sK6(X11,X10)))))) | s('type.option.option'(X10),'const.option.NONE_0') = s('type.option.option'(X10),X11)) ) | ($spl12 | $spl20)),
  inference(superposition,[],[f66,f62])).
fof(f3807,plain,(
  s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK3) | $spl1148),
  inference(cnf_transformation,[],[f3807_D])).
fof(f3807_D,plain,(
  s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK3) <=> ~$spl1148),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl1148])])).
fof(f3805,plain,(
  s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK3) | ($spl4 | $spl27 | $spl102 | $spl930)),
  inference(subsumption_resolution,[],[f3804,f72])).
fof(f3804,plain,(
  s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK4),s('type.option.option'(sK1),sK2))) = s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),sK2))) | s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK3) | ($spl4 | $spl102 | $spl930)),
  inference(forward_demodulation,[],[f3728,f56])).
fof(f3728,plain,(
  s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK4),s('type.option.option'(sK1),sK3))) = s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),sK2))) | s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK3) | ($spl102 | $spl930)),
  inference(superposition,[],[f437,f3084])).
fof(f3084,plain,(
  s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),sK2))) = s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))))) | $spl930),
  inference(cnf_transformation,[],[f3084_D])).
fof(f3084_D,plain,(
  s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),sK2))) = s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))))) <=> ~$spl930),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl930])])).
fof(f3082,plain,(
  s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK2) | s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),sK2))) = s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))))) | ($spl4 | $spl12 | $spl928)),
  inference(forward_demodulation,[],[f3081,f56])).
fof(f3081,plain,(
  s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),sK2))) = s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))))) | s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK3) | ($spl4 | $spl12 | $spl928)),
  inference(forward_demodulation,[],[f3060,f56])).
fof(f3060,plain,(
  s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),sK3))) = s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))))) | s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK3) | ($spl12 | $spl928)),
  inference(superposition,[],[f3058,f62])).
fof(f53,plain,(
  s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK4),s('type.option.option'(sK1),sK2))) != s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),sK3))) | $spl1),
  inference(cnf_transformation,[],[f53_D])).
fof(f53_D,plain,(
  s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK4),s('type.option.option'(sK1),sK2))) != s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),sK3))) <=> ~$spl1),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl1])])).
fof(f38,plain,(
  s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK4),s('type.option.option'(sK1),sK2))) != s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),sK3)))),
  inference(cnf_transformation,[],[f31])).
fof(f31,plain,(
  s('type.option.option'(sK1),sK2) = s('type.option.option'(sK1),sK3) & ! [X6] : (s('type.option.option'(sK1),sK3) != s('type.option.option'(sK1),'const.option.SOME_1'(s(sK1,X6))) | s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,X6))) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,X6)))) & s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK4),s('type.option.option'(sK1),sK2))) != s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),sK3)))),
  inference(skolemisation,[status(esa),new_symbols(skolem,[sK0,sK1,sK2,sK3,sK4,sK5])],[f29])).
fof(f29,plain,(
  ? [X0,X1,X2,X3,X4,X5] : (s('type.option.option'(X1),X2) = s('type.option.option'(X1),X3) & ! [X6] : (s('type.option.option'(X1),X3) != s('type.option.option'(X1),'const.option.SOME_1'(s(X1,X6))) | s(X0,happ(s(fun(X1,X0),X4),s(X1,X6))) = s(X0,happ(s(fun(X1,X0),X5),s(X1,X6)))) & s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X4),s('type.option.option'(X1),X2))) != s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X5),s('type.option.option'(X1),X3))))),
  inference(flattening,[],[f28])).
fof(f28,plain,(
  ? [X0,X1,X2,X3,X4,X5] : ((s('type.option.option'(X1),X2) = s('type.option.option'(X1),X3) & ! [X6] : (s('type.option.option'(X1),X3) != s('type.option.option'(X1),'const.option.SOME_1'(s(X1,X6))) | s(X0,happ(s(fun(X1,X0),X4),s(X1,X6))) = s(X0,happ(s(fun(X1,X0),X5),s(X1,X6))))) & s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X4),s('type.option.option'(X1),X2))) != s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X5),s('type.option.option'(X1),X3))))),
  inference(ennf_transformation,[],[f14])).
fof(f14,plain,(
  ~! [X0,X1,X2,X3,X4,X5] : ((s('type.option.option'(X1),X2) = s('type.option.option'(X1),X3) & ! [X6] : (s('type.option.option'(X1),X3) = s('type.option.option'(X1),'const.option.SOME_1'(s(X1,X6))) => s(X0,happ(s(fun(X1,X0),X4),s(X1,X6))) = s(X0,happ(s(fun(X1,X0),X5),s(X1,X6))))) => s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X4),s('type.option.option'(X1),X2))) = s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X5),s('type.option.option'(X1),X3))))),
  inference(flattening,[],[f13])).
fof(f13,plain,(
  ~! [X0,X1] : ! [X2,X3,X4,X5] : ((s('type.option.option'(X1),X2) = s('type.option.option'(X1),X3) & ! [X6] : (s('type.option.option'(X1),X3) = s('type.option.option'(X1),'const.option.SOME_1'(s(X1,X6))) => s(X0,happ(s(fun(X1,X0),X4),s(X1,X6))) = s(X0,happ(s(fun(X1,X0),X5),s(X1,X6))))) => s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X4),s('type.option.option'(X1),X2))) = s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X5),s('type.option.option'(X1),X3))))),
  inference(rectify,[],[f6])).
fof(f6,negated_conjecture,(
  ~! [X6,X7] : ! [X8,X9,X10,X11] : ((s('type.option.option'(X7),X8) = s('type.option.option'(X7),X9) & ! [X12] : (s('type.option.option'(X7),X9) = s('type.option.option'(X7),'const.option.SOME_1'(s(X7,X12))) => s(X6,happ(s(fun(X7,X6),X10),s(X7,X12))) = s(X6,happ(s(fun(X7,X6),X11),s(X7,X12))))) => s('type.option.option'(X6),'const.option.OPTION_MAP_2'(s(fun(X7,X6),X10),s('type.option.option'(X7),X8))) = s('type.option.option'(X6),'const.option.OPTION_MAP_2'(s(fun(X7,X6),X11),s('type.option.option'(X7),X9))))),
  inference(negated_conjecture,[],[f5])).
fof(f5,conjecture,(
  ! [X6,X7] : ! [X8,X9,X10,X11] : ((s('type.option.option'(X7),X8) = s('type.option.option'(X7),X9) & ! [X12] : (s('type.option.option'(X7),X9) = s('type.option.option'(X7),'const.option.SOME_1'(s(X7,X12))) => s(X6,happ(s(fun(X7,X6),X10),s(X7,X12))) = s(X6,happ(s(fun(X7,X6),X11),s(X7,X12))))) => s('type.option.option'(X6),'const.option.OPTION_MAP_2'(s(fun(X7,X6),X10),s('type.option.option'(X7),X8))) = s('type.option.option'(X6),'const.option.OPTION_MAP_2'(s(fun(X7,X6),X11),s('type.option.option'(X7),X9))))),
  file('thm.option.OPTION_MAP_CONG','thm.option.OPTION_MAP_CONG')).
fof(f72,plain,(
  s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK4),s('type.option.option'(sK1),sK2))) != s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),sK2))) | $spl27),
  inference(cnf_transformation,[],[f72_D])).
fof(f72_D,plain,(
  s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK4),s('type.option.option'(sK1),sK2))) != s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),sK2))) <=> ~$spl27),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl27])])).
fof(f70,plain,(
  s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK4),s('type.option.option'(sK1),sK2))) != s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),sK2))) | ($spl1 | $spl4)),
  inference(forward_demodulation,[],[f53,f56])).
fof(f65,plain,(
  ( ! [X2,X0,X1] : (s('type.option.option'(X1),'const.option.NONE_0') = s('type.option.option'(X1),'const.option.OPTION_MAP_2'(s(fun(X0,X1),X2),s('type.option.option'(X0),'const.option.NONE_0')))) ) | $spl18),
  inference(cnf_transformation,[],[f65_D])).
fof(f65_D,plain,(
  ( ! [X2,X0,X1] : (s('type.option.option'(X1),'const.option.NONE_0') = s('type.option.option'(X1),'const.option.OPTION_MAP_2'(s(fun(X0,X1),X2),s('type.option.option'(X0),'const.option.NONE_0')))) ) <=> ~$spl18),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl18])])).
fof(f48,plain,(
  ( ! [X2,X0,X1] : (s('type.option.option'(X1),'const.option.NONE_0') = s('type.option.option'(X1),'const.option.OPTION_MAP_2'(s(fun(X0,X1),X2),s('type.option.option'(X0),'const.option.NONE_0')))) )),
  inference(cnf_transformation,[],[f23])).
fof(f23,plain,(
  ! [X0,X1,X2] : s('type.option.option'(X1),'const.option.NONE_0') = s('type.option.option'(X1),'const.option.OPTION_MAP_2'(s(fun(X0,X1),X2),s('type.option.option'(X0),'const.option.NONE_0')))),
  inference(flattening,[],[f22])).
fof(f22,plain,(
  ! [X0,X1] : ! [X2] : s('type.option.option'(X1),'const.option.NONE_0') = s('type.option.option'(X1),'const.option.OPTION_MAP_2'(s(fun(X0,X1),X2),s('type.option.option'(X0),'const.option.NONE_0')))),
  inference(rectify,[],[f12])).
fof(f12,axiom,(
  ! [X7,X6] : ! [X15] : s('type.option.option'(X6),'const.option.NONE_0') = s('type.option.option'(X6),'const.option.OPTION_MAP_2'(s(fun(X7,X6),X15),s('type.option.option'(X7),'const.option.NONE_0')))),
  file('thm.option.OPTION_MAP_CONG','thm.option.OPTION_MAP_DEF|split|1')).
fof(f3910,plain,(
  $false | ($spl18 | $spl27 | $spl118)),
  inference(subsumption_resolution,[],[f3909,f65])).
fof(f3909,plain,(
  s('type.option.option'(sK0),'const.option.NONE_0') != s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK4),s('type.option.option'(sK1),'const.option.NONE_0'))) | ($spl18 | $spl27 | $spl118)),
  inference(forward_demodulation,[],[f3851,f65])).
fof(f3851,plain,(
  s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK4),s('type.option.option'(sK1),'const.option.NONE_0'))) != s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),'const.option.NONE_0'))) | ($spl27 | $spl118)),
  inference(backward_demodulation,[],[f455,f72])).
fof(f54,plain,(
  ( ! [X6] : (s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,X6))) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,X6))) | s('type.option.option'(sK1),sK3) != s('type.option.option'(sK1),'const.option.SOME_1'(s(sK1,X6)))) ) | $spl2),
  inference(cnf_transformation,[],[f54_D])).
fof(f54_D,plain,(
  ( ! [X6] : (s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,X6))) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,X6))) | s('type.option.option'(sK1),sK3) != s('type.option.option'(sK1),'const.option.SOME_1'(s(sK1,X6)))) ) <=> ~$spl2),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl2])])).
fof(f37,plain,(
  ( ! [X6] : (s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,X6))) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,X6))) | s('type.option.option'(sK1),sK3) != s('type.option.option'(sK1),'const.option.SOME_1'(s(sK1,X6)))) )),
  inference(cnf_transformation,[],[f31])).
fof(f69,plain,(
  ( ! [X6] : (s('type.option.option'(sK1),sK2) != s('type.option.option'(sK1),'const.option.SOME_1'(s(sK1,X6))) | s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,X6))) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,X6)))) ) | $spl24),
  inference(cnf_transformation,[],[f69_D])).
fof(f69_D,plain,(
  ( ! [X6] : (s('type.option.option'(sK1),sK2) != s('type.option.option'(sK1),'const.option.SOME_1'(s(sK1,X6))) | s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,X6))) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,X6)))) ) <=> ~$spl24),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl24])])).
fof(f68,plain,(
  ( ! [X6] : (s('type.option.option'(sK1),sK2) != s('type.option.option'(sK1),'const.option.SOME_1'(s(sK1,X6))) | s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,X6))) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,X6)))) ) | ($spl2 | $spl4)),
  inference(forward_demodulation,[],[f54,f56])).
fof(f62,plain,(
  ( ! [X0,X1] : (s('type.option.option'(X0),X1) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,sK6(X1,X0)))) | s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1)) ) | $spl12),
  inference(cnf_transformation,[],[f62_D])).
fof(f62_D,plain,(
  ( ! [X0,X1] : (s('type.option.option'(X0),X1) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,sK6(X1,X0)))) | s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1)) ) <=> ~$spl12),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl12])])).
fof(f43,plain,(
  ( ! [X0,X1] : (s('type.option.option'(X0),X1) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,sK6(X1,X0)))) | s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1)) )),
  inference(cnf_transformation,[],[f32])).
fof(f32,plain,(
  ! [X0,X1] : (s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1) | s('type.option.option'(X0),X1) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,sK6(X1,X0)))))),
  inference(skolemisation,[status(esa),new_symbols(skolem,[sK6])],[f17])).
fof(f17,plain,(
  ! [X0,X1] : (s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1) | ? [X2] : s('type.option.option'(X0),X1) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))))),
  inference(flattening,[],[f16])).
fof(f16,plain,(
  ! [X0] : ! [X1] : (s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1) | ? [X2] : s('type.option.option'(X0),X1) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))))),
  inference(rectify,[],[f9])).
fof(f9,axiom,(
  ! [X7] : ! [X13] : (s('type.option.option'(X7),'const.option.NONE_0') = s('type.option.option'(X7),X13) | ? [X12] : s('type.option.option'(X7),X13) = s('type.option.option'(X7),'const.option.SOME_1'(s(X7,X12))))),
  file('thm.option.OPTION_MAP_CONG','thm.option.option_nchotomy')).
fof(f367,plain,(
  ( ! [X0] : (s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(X0,sK1)))) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,sK6(X0,sK1)))) | s('type.option.option'(sK1),sK2) != s('type.option.option'(sK1),X0) | s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),X0)) ) | $spl86),
  inference(cnf_transformation,[],[f367_D])).
fof(f367_D,plain,(
  ( ! [X0] : (s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(X0,sK1)))) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,sK6(X0,sK1)))) | s('type.option.option'(sK1),sK2) != s('type.option.option'(sK1),X0) | s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),X0)) ) <=> ~$spl86),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl86])])).
fof(f354,plain,(
  ( ! [X0] : (s('type.option.option'(sK1),sK2) != s('type.option.option'(sK1),X0) | s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(X0,sK1)))) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,sK6(X0,sK1)))) | s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),X0)) ) | ($spl12 | $spl24)),
  inference(superposition,[],[f69,f62])).
fof(f64,plain,(
  ( ! [X2,X0,X1] : (s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1))) != s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))) | s(X0,X1) = s(X0,X2)) ) | $spl16),
  inference(cnf_transformation,[],[f64_D])).
fof(f64_D,plain,(
  ( ! [X2,X0,X1] : (s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1))) != s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))) | s(X0,X1) = s(X0,X2)) ) <=> ~$spl16),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl16])])).
fof(f46,plain,(
  ( ! [X2,X0,X1] : (s(X0,X1) = s(X0,X2) | s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1))) != s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2)))) )),
  inference(cnf_transformation,[],[f34])).
fof(f34,plain,(
  ! [X0,X1,X2] : ((s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1))) != s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))) | s(X0,X1) = s(X0,X2)) & (s(X0,X1) != s(X0,X2) | s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1))) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2)))))),
  inference(nnf_transformation,[],[f21])).
fof(f21,plain,(
  ! [X0,X1,X2] : (s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1))) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))) <=> s(X0,X1) = s(X0,X2))),
  inference(flattening,[],[f20])).
fof(f20,plain,(
  ! [X0] : ! [X1,X2] : (s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1))) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))) <=> s(X0,X1) = s(X0,X2))),
  inference(rectify,[],[f10])).
fof(f10,axiom,(
  ! [X7] : ! [X12,X14] : (s('type.option.option'(X7),'const.option.SOME_1'(s(X7,X12))) = s('type.option.option'(X7),'const.option.SOME_1'(s(X7,X14))) <=> s(X7,X12) = s(X7,X14))),
  file('thm.option.OPTION_MAP_CONG','thm.option.SOME_|49||49|')).
fof(f375,plain,(
  ( ! [X0,X1] : (s('type.option.option'(sK1),sK2) != s('type.option.option'(sK1),X0) | s(sK0,X1) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,sK6(X0,sK1)))) | s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,X1))) != s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(X0,sK1)))))) | s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),X0)) ) | $spl94),
  inference(cnf_transformation,[],[f375_D])).
fof(f375_D,plain,(
  ( ! [X0,X1] : (s('type.option.option'(sK1),sK2) != s('type.option.option'(sK1),X0) | s(sK0,X1) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,sK6(X0,sK1)))) | s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,X1))) != s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(X0,sK1)))))) | s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),X0)) ) <=> ~$spl94),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl94])])).
fof(f371,plain,(
  ( ! [X0,X1] : (s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,X1))) != s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(X0,sK1)))))) | s(sK0,X1) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,sK6(X0,sK1)))) | s('type.option.option'(sK1),sK2) != s('type.option.option'(sK1),X0) | s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),X0)) ) | ($spl16 | $spl86)),
  inference(superposition,[],[f64,f367])).
fof(f56,plain,(
  s('type.option.option'(sK1),sK2) = s('type.option.option'(sK1),sK3) | $spl4),
  inference(cnf_transformation,[],[f56_D])).
fof(f56_D,plain,(
  s('type.option.option'(sK1),sK2) = s('type.option.option'(sK1),sK3) <=> ~$spl4),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl4])])).
fof(f36,plain,(
  s('type.option.option'(sK1),sK2) = s('type.option.option'(sK1),sK3)),
  inference(cnf_transformation,[],[f31])).
fof(f453,plain,(
  ( ! [X0] : (s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,X0))) != s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))))) | s(sK0,X0) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,sK6(sK3,sK1))))) ) | $spl116),
  inference(cnf_transformation,[],[f453_D])).
fof(f453_D,plain,(
  ( ! [X0] : (s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,X0))) != s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))))) | s(sK0,X0) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,sK6(sK3,sK1))))) ) <=> ~$spl116),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl116])])).
fof(f452,plain,(
  ( ! [X0] : (s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK2) | s(sK0,X0) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,sK6(sK3,sK1)))) | s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,X0))) != s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1))))))) ) | ($spl4 | $spl94)),
  inference(forward_demodulation,[],[f451,f56])).
fof(f451,plain,(
  ( ! [X0] : (s(sK0,X0) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,sK6(sK3,sK1)))) | s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,X0))) != s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))))) | s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK3)) ) | ($spl4 | $spl94)),
  inference(trivial_inequality_removal,[],[f444])).
fof(f444,plain,(
  ( ! [X0] : (s('type.option.option'(sK1),sK2) != s('type.option.option'(sK1),sK2) | s(sK0,X0) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,sK6(sK3,sK1)))) | s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,X0))) != s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))))) | s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK3)) ) | ($spl4 | $spl94)),
  inference(superposition,[],[f375,f56])).
fof(f473,plain,(
  s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,sK6(sK3,sK1)))) | $spl136),
  inference(cnf_transformation,[],[f473_D])).
fof(f473_D,plain,(
  s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,sK6(sK3,sK1)))) <=> ~$spl136),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl136])])).
fof(f467,plain,(
  s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))) = s(sK0,happ(s(fun(sK1,sK0),sK5),s(sK1,sK6(sK3,sK1)))) | $spl116),
  inference(equality_resolution,[],[f453])).
fof(f66,plain,(
  ( ! [X2,X0,X3,X1] : (s('type.option.option'(X0),'const.option.SOME_1'(s(X0,happ(s(fun(X1,X0),X2),s(X1,X3))))) = s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X2),s('type.option.option'(X1),'const.option.SOME_1'(s(X1,X3)))))) ) | $spl20),
  inference(cnf_transformation,[],[f66_D])).
fof(f66_D,plain,(
  ( ! [X2,X0,X3,X1] : (s('type.option.option'(X0),'const.option.SOME_1'(s(X0,happ(s(fun(X1,X0),X2),s(X1,X3))))) = s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X2),s('type.option.option'(X1),'const.option.SOME_1'(s(X1,X3)))))) ) <=> ~$spl20),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl20])])).
fof(f49,plain,(
  ( ! [X2,X0,X3,X1] : (s('type.option.option'(X0),'const.option.SOME_1'(s(X0,happ(s(fun(X1,X0),X2),s(X1,X3))))) = s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X2),s('type.option.option'(X1),'const.option.SOME_1'(s(X1,X3)))))) )),
  inference(cnf_transformation,[],[f25])).
fof(f25,plain,(
  ! [X0,X1,X2,X3] : s('type.option.option'(X0),'const.option.SOME_1'(s(X0,happ(s(fun(X1,X0),X2),s(X1,X3))))) = s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X2),s('type.option.option'(X1),'const.option.SOME_1'(s(X1,X3)))))),
  inference(flattening,[],[f24])).
fof(f24,plain,(
  ! [X0,X1] : ! [X2,X3] : s('type.option.option'(X0),'const.option.SOME_1'(s(X0,happ(s(fun(X1,X0),X2),s(X1,X3))))) = s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X2),s('type.option.option'(X1),'const.option.SOME_1'(s(X1,X3)))))),
  inference(rectify,[],[f11])).
fof(f11,axiom,(
  ! [X6,X7] : ! [X15,X12] : s('type.option.option'(X6),'const.option.SOME_1'(s(X6,happ(s(fun(X7,X6),X15),s(X7,X12))))) = s('type.option.option'(X6),'const.option.OPTION_MAP_2'(s(fun(X7,X6),X15),s('type.option.option'(X7),'const.option.SOME_1'(s(X7,X12)))))),
  file('thm.option.OPTION_MAP_CONG','thm.option.OPTION_MAP_DEF|split|0')).
fof(f63,plain,(
  ( ! [X2,X0,X1] : (s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1))) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))) | s(X0,X1) != s(X0,X2)) ) | $spl14),
  inference(cnf_transformation,[],[f63_D])).
fof(f63_D,plain,(
  ( ! [X2,X0,X1] : (s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1))) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))) | s(X0,X1) != s(X0,X2)) ) <=> ~$spl14),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl14])])).
fof(f47,plain,(
  ( ! [X2,X0,X1] : (s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1))) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))) | s(X0,X1) != s(X0,X2)) )),
  inference(cnf_transformation,[],[f34])).
fof(f435,plain,(
  ( ! [X6,X4,X8,X7,X5] : (s(X4,X8) != s(X4,happ(s(fun(X5,X4),X6),s(X5,X7))) | s('type.option.option'(X4),'const.option.SOME_1'(s(X4,X8))) = s('type.option.option'(X4),'const.option.OPTION_MAP_2'(s(fun(X5,X4),X6),s('type.option.option'(X5),'const.option.SOME_1'(s(X5,X7)))))) ) | $spl98),
  inference(cnf_transformation,[],[f435_D])).
fof(f435_D,plain,(
  ( ! [X6,X4,X8,X7,X5] : (s(X4,X8) != s(X4,happ(s(fun(X5,X4),X6),s(X5,X7))) | s('type.option.option'(X4),'const.option.SOME_1'(s(X4,X8))) = s('type.option.option'(X4),'const.option.OPTION_MAP_2'(s(fun(X5,X4),X6),s('type.option.option'(X5),'const.option.SOME_1'(s(X5,X7)))))) ) <=> ~$spl98),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl98])])).
fof(f397,plain,(
  ( ! [X6,X4,X8,X7,X5] : (s('type.option.option'(X4),'const.option.SOME_1'(s(X4,X8))) = s('type.option.option'(X4),'const.option.OPTION_MAP_2'(s(fun(X5,X4),X6),s('type.option.option'(X5),'const.option.SOME_1'(s(X5,X7))))) | s(X4,X8) != s(X4,happ(s(fun(X5,X4),X6),s(X5,X7)))) ) | ($spl14 | $spl20)),
  inference(superposition,[],[f66,f63])).
fof(f3048,plain,(
  ( ! [X38] : (s(sK0,X38) != s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))) | s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,X38))) = s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),'const.option.SOME_1'(s(sK1,sK6(sK3,sK1))))))) ) | $spl922),
  inference(cnf_transformation,[],[f3048_D])).
fof(f3048_D,plain,(
  ( ! [X38] : (s(sK0,X38) != s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))) | s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,X38))) = s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),'const.option.SOME_1'(s(sK1,sK6(sK3,sK1))))))) ) <=> ~$spl922),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl922])])).
fof(f2984,plain,(
  ( ! [X38] : (s(sK0,X38) != s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))) | s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,X38))) = s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),'const.option.SOME_1'(s(sK1,sK6(sK3,sK1))))))) ) | ($spl98 | $spl136)),
  inference(superposition,[],[f435,f473])).
fof(f3058,plain,(
  s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))))) = s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),'const.option.SOME_1'(s(sK1,sK6(sK3,sK1)))))) | $spl928),
  inference(cnf_transformation,[],[f3058_D])).
fof(f3058_D,plain,(
  s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))))) = s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),'const.option.SOME_1'(s(sK1,sK6(sK3,sK1)))))) <=> ~$spl928),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl928])])).
fof(f3053,plain,(
  s('type.option.option'(sK0),'const.option.SOME_1'(s(sK0,happ(s(fun(sK1,sK0),sK4),s(sK1,sK6(sK3,sK1)))))) = s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK5),s('type.option.option'(sK1),'const.option.SOME_1'(s(sK1,sK6(sK3,sK1)))))) | $spl922),
  inference(equality_resolution,[],[f3048])).
% SZS output end Proof for thm.option
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Refutation

% Active clauses: 86
% Passive clauses: 623
% Generated clauses: 3866
% Final active clauses: 53
% Final passive clauses: 339
% Input formulas: 11
% Initial clauses: 15
% 
% Duplicate literals: 164
% Trivial inequalities: 52
% Fw subsumption resolutions: 223
% Fw demodulations: 433
% Bw demodulations: 219
% Condensations: 151
% 
% Simple tautologies: 81
% Equational tautologies: 18
% Forward subsumptions: 1110
% Fw demodulations to eq. taut.: 8
% Bw demodulations to eq. taut.: 4
% 
% Binary resolution: 4
% Forward superposition: 1111
% Backward superposition: 729
% Self superposition: 45
% Equality factoring: 30
% Equality resolution: 34
% 
% Split clauses: 45
% Split components: 95
% SAT solver clauses: 943
% SAT solver unit clauses: 22
% SAT solver binary clauses: 33
% SAT solver learnt clauses: 1
% 
% Sat splits: 45
% Sat splitting refutations: 22
% 
% TWLsolver clauses: 942
% TWLsolver calls for satisfiability: 110
% 
% Memory used [KB]: 4733
% Time elapsed: 0.189 s
% ------------------------------
% ------------------------------
% Success in time 0.819 s
