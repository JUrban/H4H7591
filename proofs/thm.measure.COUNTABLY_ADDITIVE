Hi Geoff, go and have some cold beer while I am trying to solve this very hard problem!
% remaining time: 299 next slice time: 5
dis+11_7_3 on thm.measure
% (71921)Time limit reached!
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Time limit
% Termination phase: Saturation

% Active clauses: 1071
% Passive clauses: 9560
% Generated clauses: 25146
% Final active clauses: 1067
% Final passive clauses: 8190
% Input formulas: 53
% Initial clauses: 237
% 
% Duplicate literals: 368
% Trivial inequalities: 88
% Fw subsumption resolutions: 3199
% Fw demodulations: 1433
% Bw demodulations: 3
% 
% Simple tautologies: 290
% Equational tautologies: 36
% Forward subsumptions: 9418
% 
% Binary resolution: 10071
% Factoring: 806
% Forward superposition: 2714
% Backward superposition: 5883
% Self superposition: 26
% Equality factoring: 26
% Equality resolution: 8
% 
% Split clauses: 745
% Split components: 1517
% SAT solver clauses: 1059
% SAT solver unit clauses: 26
% SAT solver binary clauses: 228
% 
% Sat splits: 745
% 
% TWLsolver clauses: 1059
% TWLsolver calls for satisfiability: 482
% 
% Memory used [KB]: 13304
% Time elapsed: 0.600 s
% ------------------------------
% ------------------------------
% remaining time: 293 next slice time: 6
lrs-11_2_cond=on:fde=unused:gs=on:nwc=3:stl=30:sdd=off:sfr=on:ssfp=100000:ssfq=1.4:smm=sco:ssnc=all_4 on thm.measure
% (71943)Time limit reached!
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Time limit
% Termination phase: Saturation

% Active clauses: 500
% Passive clauses: 2970
% Generated clauses: 14325
% Final active clauses: 485
% Final passive clauses: 2423
% Input formulas: 53
% Initial clauses: 237
% 
% Duplicate literals: 285
% Trivial inequalities: 74
% Fw subsumption resolutions: 1116
% Fw demodulations: 781
% Bw demodulations: 57
% Condensations: 429
% Global subsumptions: 13
% 
% Simple tautologies: 346
% Equational tautologies: 19
% Forward subsumptions: 4781
% 
% Binary resolution: 3820
% Factoring: 137
% Forward superposition: 2203
% Backward superposition: 2120
% Self superposition: 31
% Equality factoring: 28
% Equality resolution: 14
% 
% Split clauses: 85
% Split components: 170
% SAT solver clauses: 3565
% SAT solver unit clauses: 211
% SAT solver binary clauses: 74
% SAT solver learnt clauses: 26
% SAT solver learnt literals: 10
% 
% Sat splits: 85
% Sat splitting refutations: 3
% 
% TWLsolver clauses: 3513
% TWLsolver calls for satisfiability: 2058
% 
% Memory used [KB]: 15479
% Time elapsed: 0.700 s
% ------------------------------
% ------------------------------
% remaining time: 286 next slice time: 103
lrs+11_2_br=off:cond=on:fde=none:gs=on:gsaa=full_model:lwlo=on:nwc=2:sas=minisat:stl=30:ssfp=100000:ssfq=1.4:smm=sco:ssnc=none:sp=occurrence:urr=on_98 on thm.measure
% (71960)Time limit reached!
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Time limit
% Termination phase: Saturation

% Active clauses: 3491
% Passive clauses: 15528
% Generated clauses: 161257
% Final active clauses: 2808
% Final passive clauses: 7307
% Input formulas: 53
% Initial clauses: 237
% Discarded non-redundant clauses: 5831
% 
% Duplicate literals: 10132
% Trivial inequalities: 112
% Fw subsumption resolutions: 4026
% Fw demodulations: 23762
% Bw demodulations: 1901
% Condensations: 13514
% Global subsumptions: 398
% 
% Simple tautologies: 181
% Equational tautologies: 1744
% Forward subsumptions: 78839
% Bw demodulations to eq. taut.: 47
% 
% Unit resulting resolution: 43224
% Factoring: 1
% Forward superposition: 24908
% Backward superposition: 37407
% Self superposition: 174
% Equality factoring: 138
% Equality resolution: 5
% 
% Split clauses: 303
% Split components: 613
% SAT solver clauses: 17574
% SAT solver unit clauses: 1507
% SAT solver binary clauses: 5503
% 
% Sat splits: 303
% Sat splitting refutations: 1039
% 
% Memory used [KB]: 97354
% Time elapsed: 10.400 s
% ------------------------------
% ------------------------------
% remaining time: 182 next slice time: 39
dis+11_5_fde=none:nwc=1:sas=minisat:sd=1:ss=axioms:st=5.0:sos=all:sdd=large:sser=off:sfr=on:ssfp=100000:ssfq=2.0:ssnc=none_37 on thm.measure
% (72244)Time limit reached!
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Time limit
% Termination phase: Saturation

% Active clauses: 1727
% Passive clauses: 46136
% Generated clauses: 167406
% Final active clauses: 1579
% Final passive clauses: 42380
% Input formulas: 53
% Initial clauses: 234
% 
% Selected by SInE selection: 50
% SInE iterations: 1
% 
% Duplicate literals: 7148
% Trivial inequalities: 439
% Fw subsumption resolutions: 15283
% Fw demodulations: 813
% Bw demodulations: 108
% 
% Simple tautologies: 5763
% Equational tautologies: 1121
% Forward subsumptions: 84757
% 
% Binary resolution: 129670
% Factoring: 752
% Forward superposition: 10384
% Backward superposition: 1458
% Self superposition: 13
% Equality resolution: 80
% 
% Split clauses: 7056
% Split components: 15952
% SAT solver clauses: 7403
% SAT solver unit clauses: 63
% SAT solver binary clauses: 3707
% 
% Sat splits: 7056
% Sat splitting refutations: 75
% 
% Memory used [KB]: 48101
% Time elapsed: 4.0000 s
% ------------------------------
% ------------------------------
% remaining time: 142 next slice time: 6
lrs+1002_2:3_br=off:fde=unused:gs=on:gsaa=from_current:gsem=on:gsssp=full:nwc=1:sas=minisat:stl=30:sac=on:sser=off:sfr=on:ssfp=100000:ssfq=2.0:ssnc=none:sp=reverse_arity:urr=on_4 on thm.measure
% (72368)Time limit reached!
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Time limit
% Termination phase: Saturation

% Active clauses: 465
% Passive clauses: 4604
% Generated clauses: 17860
% Final active clauses: 448
% Final passive clauses: 3967
% Input formulas: 53
% Initial clauses: 237
% 
% Duplicate literals: 439
% Trivial inequalities: 43
% Fw subsumption resolutions: 893
% Fw demodulations: 1727
% Bw demodulations: 126
% Global subsumptions: 5
% 
% Simple tautologies: 494
% Equational tautologies: 70
% Forward subsumptions: 9527
% 
% Unit resulting resolution: 6180
% Factoring: 2
% Forward superposition: 3418
% Backward superposition: 4648
% Self superposition: 67
% Equality factoring: 6
% Equality resolution: 7
% 
% Split clauses: 25
% Split components: 51
% SAT solver clauses: 4694
% SAT solver unit clauses: 464
% SAT solver binary clauses: 1018
% 
% Sat splits: 25
% Sat splitting refutations: 58
% 
% Memory used [KB]: 13176
% Time elapsed: 0.700 s
% ------------------------------
% ------------------------------
% remaining time: 135 next slice time: 15
lrs+1011_12_bs=on:bsr=unit_only:cond=on:gs=on:gsaa=from_current:gsssp=full:nwc=1.1:sas=minisat:stl=60:sos=all:sac=on:sdd=off:sser=off:sfr=on:ssfp=100000:ssfq=1.2:ssnc=none:sp=reverse_arity:updr=off_14 on thm.measure
% (72381)Time limit reached!
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Time limit
% Termination phase: Saturation

% Active clauses: 1225
% Passive clauses: 6380
% Generated clauses: 20126
% Final active clauses: 614
% Final passive clauses: 2592
% Input formulas: 53
% Initial clauses: 237
% 
% Duplicate literals: 747
% Trivial inequalities: 59
% Fw subsumption resolutions: 705
% Bw subsumption resolutions: 1674
% Fw demodulations: 799
% Bw demodulations: 194
% Condensations: 1265
% Global subsumptions: 501
% 
% Simple tautologies: 1152
% Equational tautologies: 36
% Forward subsumptions: 7777
% Backward subsumptions: 1401
% 
% Binary resolution: 5884
% Factoring: 49
% Forward superposition: 2588
% Backward superposition: 2504
% Self superposition: 65
% Equality factoring: 2
% Equality resolution: 12
% 
% Split clauses: 20
% Split components: 40
% SAT solver clauses: 7494
% SAT solver unit clauses: 787
% SAT solver binary clauses: 1459
% 
% Sat splits: 20
% Sat splitting refutations: 591
% 
% Memory used [KB]: 25713
% Time elapsed: 1.600 s
% ------------------------------
% ------------------------------
% remaining time: 119 next slice time: 9
lrs+10_8:1_bd=preordered:bs=on:ccuc=first:fsr=off:fde=unused:gs=on:gsaa=from_current:gsem=on:gsssp=full:nwc=1:nicw=on:sas=minisat:stl=120:sos=on:sscc=on:sser=off:sfr=on:ssfp=4000:ssfq=1.0:ssnc=none:sp=reverse_arity:urr=on_7 on thm.measure
% (72438)Time limit reached!
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Time limit
% Termination phase: Saturation

% Active clauses: 881
% Passive clauses: 3872
% Generated clauses: 25470
% Final active clauses: 565
% Final passive clauses: 1834
% Input formulas: 53
% Initial clauses: 237
% 
% Duplicate literals: 199
% Trivial inequalities: 14
% Fw demodulations: 4339
% Bw demodulations: 59
% Global subsumptions: 255
% 
% Simple tautologies: 772
% Equational tautologies: 225
% Forward subsumptions: 13640
% Backward subsumptions: 1083
% 
% Binary resolution: 6997
% Unit resulting resolution: 10199
% Factoring: 22
% Forward superposition: 1018
% Backward superposition: 616
% Self superposition: 2
% Equality factoring: 2
% Equality resolution: 8
% 
% Split clauses: 74
% Split components: 151
% SAT solver clauses: 8065
% SAT solver unit clauses: 24
% SAT solver binary clauses: 4568
% 
% Sat splits: 74
% Sat splitting refutations: 300
% 
% Memory used [KB]: 19317
% Time elapsed: 1.0000 s
% ------------------------------
% ------------------------------
% remaining time: 109 next slice time: 85
lrs+1_5:4_cond=on:fsr=off:fde=none:gs=on:gsem=on:lwlo=on:nm=64:nwc=1:stl=60:sos=all:spl=off_80 on thm.measure
% Refutation found. Thanks to Tanya!
% SZS status Theorem for thm.measure
% SZS output start Proof for thm.measure
fof(f6203,plain,(
  $false),
  inference(trivial_inequality_removal,[],[f6112])).
fof(f6112,plain,(
  s(bool,'T_0') != s(bool,'T_0')),
  inference(resolution,[],[f6099,f287])).
fof(f287,plain,(
  ( ! [X0] : (p(s(bool,X0)) | s(bool,'T_0') != s(bool,X0)) )),
  inference(cnf_transformation,[],[f176])).
fof(f176,plain,(
  ! [X0] : ((s(bool,'T_0') != s(bool,X0) | p(s(bool,X0))) & (~p(s(bool,X0)) | s(bool,'T_0') = s(bool,X0)))),
  inference(nnf_transformation,[],[f69])).
fof(f69,plain,(
  ! [X0] : (s(bool,'T_0') = s(bool,X0) <=> p(s(bool,X0)))),
  inference(rectify,[],[f24])).
fof(f24,axiom,(
  ! [X14] : (s(bool,'T_0') = s(bool,X14) <=> p(s(bool,X14)))),
  file('thm.measure.COUNTABLY_ADDITIVE','thm.bool.EQ_CLAUSES|split|1')).
fof(f6099,plain,(
  ~p(s(bool,'T_0'))),
  inference(global_subsumption,[],[f5994,f1807])).
fof(f1807,plain,(
  s('type.num.num',sK5(sK4,sK2,sK1)) != s('type.num.num',sK6(sK4,sK2,sK1))),
  inference(resolution,[],[f1582,f269])).
fof(f269,plain,(
  p(s(bool,'T_0'))),
  inference(cnf_transformation,[],[f7])).
fof(f7,axiom,(
  p(s(bool,'T_0'))),
  file('thm.measure.COUNTABLY_ADDITIVE','thm.bool.TRUTH')).
fof(f1582,plain,(
  ~p(s(bool,'T_0')) | s('type.num.num',sK5(sK4,sK2,sK1)) != s('type.num.num',sK6(sK4,sK2,sK1))),
  inference(global_subsumption,[],[f1581,f268])).
fof(f268,plain,(
  ~p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun('type.num.num',fun(sK1,bool)),sK4))),s('type.realax.real',happ(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun(sK1,bool),sK3))))))),
  inference(cnf_transformation,[],[f172])).
fof(f172,plain,(
  p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2)))) & p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(sK1,bool)),sK4),s(fun(fun('type.num.num',fun(sK1,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(sK1,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2)))))))) & ! [X4,X5] : (s('type.num.num',X4) = s('type.num.num',X5) | p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',X4))),s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',X5))))))) & s(fun(sK1,bool),sK3) = s(fun(sK1,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(sK1,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(sK1,bool)),sK4),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))) & p(s(bool,'const.bool.IN_2'(s(fun(sK1,bool),sK3),s(fun(fun(sK1,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2)))))) & ~p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun('type.num.num',fun(sK1,bool)),sK4))),s('type.realax.real',happ(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun(sK1,bool),sK3))))))),
  inference(skolemisation,[status(esa),new_symbols(skolem,[sK1,sK2,sK3,sK4])],[f140])).
fof(f140,plain,(
  ? [X0,X1,X2,X3] : (p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))) & p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X0,bool)),X3),s(fun(fun('type.num.num',fun(X0,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))))) & ! [X4,X5] : (s('type.num.num',X4) = s('type.num.num',X5) | p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X3),s('type.num.num',X4))),s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X3),s('type.num.num',X5))))))) & s(fun(X0,bool),X2) = s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X3),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))) & p(s(bool,'const.bool.IN_2'(s(fun(X0,bool),X2),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))) & ~p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun('type.num.num',fun(X0,bool)),X3))),s('type.realax.real',happ(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun(X0,bool),X2)))))))),
  inference(flattening,[],[f139])).
fof(f139,plain,(
  ? [X0,X1,X2,X3] : ((p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))) & p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X0,bool)),X3),s(fun(fun('type.num.num',fun(X0,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))))) & ! [X4,X5] : (s('type.num.num',X4) = s('type.num.num',X5) | p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X3),s('type.num.num',X4))),s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X3),s('type.num.num',X5))))))) & s(fun(X0,bool),X2) = s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X3),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))) & p(s(bool,'const.bool.IN_2'(s(fun(X0,bool),X2),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))))))) & ~p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun('type.num.num',fun(X0,bool)),X3))),s('type.realax.real',happ(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun(X0,bool),X2)))))))),
  inference(ennf_transformation,[],[f56])).
fof(f56,plain,(
  ~! [X0,X1,X2,X3] : ((p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))) & p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X0,bool)),X3),s(fun(fun('type.num.num',fun(X0,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))))) & ! [X4,X5] : (s('type.num.num',X4) != s('type.num.num',X5) => p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X3),s('type.num.num',X4))),s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X3),s('type.num.num',X5))))))) & s(fun(X0,bool),X2) = s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X3),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))) & p(s(bool,'const.bool.IN_2'(s(fun(X0,bool),X2),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))))))) => p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun('type.num.num',fun(X0,bool)),X3))),s('type.realax.real',happ(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun(X0,bool),X2)))))))),
  inference(flattening,[],[f55])).
fof(f55,plain,(
  ~! [X0] : ! [X1,X2,X3] : ((p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))) & p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X0,bool)),X3),s(fun(fun('type.num.num',fun(X0,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))))) & ! [X4,X5] : (~s('type.num.num',X4) = s('type.num.num',X5) => p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X3),s('type.num.num',X4))),s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X3),s('type.num.num',X5))))))) & s(fun(X0,bool),X2) = s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X3),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))) & p(s(bool,'const.bool.IN_2'(s(fun(X0,bool),X2),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))))))) => p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun('type.num.num',fun(X0,bool)),X3))),s('type.realax.real',happ(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun(X0,bool),X2)))))))),
  inference(rectify,[],[f6])).
fof(f6,negated_conjecture,(
  ~! [X6] : ! [X7,X8,X9] : ((p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X6,bool),'type.pair.prod'(fun(fun(X6,bool),bool),fun(fun(X6,bool),'type.realax.real'))),X7)))) & p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X6,bool)),X9),s(fun(fun('type.num.num',fun(X6,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X6,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X6,bool),'type.pair.prod'(fun(fun(X6,bool),bool),fun(fun(X6,bool),'type.realax.real'))),X7)))))))) & ! [X10,X11] : (~s('type.num.num',X10) = s('type.num.num',X11) => p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X6,bool),happ(s(fun('type.num.num',fun(X6,bool)),X9),s('type.num.num',X10))),s(fun(X6,bool),happ(s(fun('type.num.num',fun(X6,bool)),X9),s('type.num.num',X11))))))) & s(fun(X6,bool),X8) = s(fun(X6,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X6,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X6,bool)),X9),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))) & p(s(bool,'const.bool.IN_2'(s(fun(X6,bool),X8),s(fun(fun(X6,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X6,bool),'type.pair.prod'(fun(fun(X6,bool),bool),fun(fun(X6,bool),'type.realax.real'))),X7))))))) => p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X6,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X6,bool),'type.pair.prod'(fun(fun(X6,bool),bool),fun(fun(X6,bool),'type.realax.real'))),X7))),s(fun('type.num.num',fun(X6,bool)),X9))),s('type.realax.real',happ(s(fun(fun(X6,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X6,bool),'type.pair.prod'(fun(fun(X6,bool),bool),fun(fun(X6,bool),'type.realax.real'))),X7))),s(fun(X6,bool),X8)))))))),
  inference(negated_conjecture,[],[f5])).
fof(f5,conjecture,(
  ! [X6] : ! [X7,X8,X9] : ((p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X6,bool),'type.pair.prod'(fun(fun(X6,bool),bool),fun(fun(X6,bool),'type.realax.real'))),X7)))) & p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X6,bool)),X9),s(fun(fun('type.num.num',fun(X6,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X6,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X6,bool),'type.pair.prod'(fun(fun(X6,bool),bool),fun(fun(X6,bool),'type.realax.real'))),X7)))))))) & ! [X10,X11] : (~s('type.num.num',X10) = s('type.num.num',X11) => p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X6,bool),happ(s(fun('type.num.num',fun(X6,bool)),X9),s('type.num.num',X10))),s(fun(X6,bool),happ(s(fun('type.num.num',fun(X6,bool)),X9),s('type.num.num',X11))))))) & s(fun(X6,bool),X8) = s(fun(X6,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X6,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X6,bool)),X9),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))) & p(s(bool,'const.bool.IN_2'(s(fun(X6,bool),X8),s(fun(fun(X6,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X6,bool),'type.pair.prod'(fun(fun(X6,bool),bool),fun(fun(X6,bool),'type.realax.real'))),X7))))))) => p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X6,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X6,bool),'type.pair.prod'(fun(fun(X6,bool),bool),fun(fun(X6,bool),'type.realax.real'))),X7))),s(fun('type.num.num',fun(X6,bool)),X9))),s('type.realax.real',happ(s(fun(fun(X6,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X6,bool),'type.pair.prod'(fun(fun(X6,bool),bool),fun(fun(X6,bool),'type.realax.real'))),X7))),s(fun(X6,bool),X8)))))))),
  file('thm.measure.COUNTABLY_ADDITIVE','thm.measure.COUNTABLY_ADDITIVE')).
fof(f1581,plain,(
  ~p(s(bool,'T_0')) | p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun('type.num.num',fun(sK1,bool)),sK4))),s('type.realax.real',happ(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun(sK1,bool),sK3)))))) | s('type.num.num',sK5(sK4,sK2,sK1)) != s('type.num.num',sK6(sK4,sK2,sK1))),
  inference(duplicate_literal_removal,[],[f1580])).
fof(f1580,plain,(
  ~p(s(bool,'T_0')) | ~p(s(bool,'T_0')) | p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun('type.num.num',fun(sK1,bool)),sK4))),s('type.realax.real',happ(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun(sK1,bool),sK3)))))) | s('type.num.num',sK5(sK4,sK2,sK1)) != s('type.num.num',sK6(sK4,sK2,sK1))),
  inference(forward_demodulation,[],[f1579,f816])).
fof(f816,plain,(
  s(bool,'T_0') = s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2)))),
  inference(resolution,[],[f263,f286])).
fof(f286,plain,(
  ( ! [X0] : (s(bool,'T_0') = s(bool,X0) | ~p(s(bool,X0))) )),
  inference(cnf_transformation,[],[f175])).
fof(f175,plain,(
  ! [X0] : ((s(bool,'T_0') != s(bool,X0) | p(s(bool,X0))) & (~p(s(bool,X0)) | s(bool,'T_0') = s(bool,X0)))),
  inference(nnf_transformation,[],[f68])).
fof(f68,plain,(
  ! [X0] : (s(bool,'T_0') = s(bool,X0) <=> p(s(bool,X0)))),
  inference(rectify,[],[f23])).
fof(f23,axiom,(
  ! [X14] : (s(bool,'T_0') = s(bool,X14) <=> p(s(bool,X14)))),
  file('thm.measure.COUNTABLY_ADDITIVE','thm.bool.EQ_CLAUSES|split|0')).
fof(f263,plain,(
  p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))))),
  inference(cnf_transformation,[],[f172])).
fof(f1579,plain,(
  ~p(s(bool,'T_0')) | p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun('type.num.num',fun(sK1,bool)),sK4))),s('type.realax.real',happ(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun(sK1,bool),sK3)))))) | s('type.num.num',sK5(sK4,sK2,sK1)) != s('type.num.num',sK6(sK4,sK2,sK1)) | ~p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))))),
  inference(forward_demodulation,[],[f1578,f1108])).
fof(f1108,plain,(
  s(bool,'T_0') = s(bool,'const.bool.IN_2'(s(fun(sK1,bool),sK3),s(fun(fun(sK1,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2)))))),
  inference(resolution,[],[f267,f286])).
fof(f267,plain,(
  p(s(bool,'const.bool.IN_2'(s(fun(sK1,bool),sK3),s(fun(fun(sK1,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))))))),
  inference(cnf_transformation,[],[f172])).
fof(f1578,plain,(
  ~p(s(bool,'const.bool.IN_2'(s(fun(sK1,bool),sK3),s(fun(fun(sK1,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2)))))) | p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun('type.num.num',fun(sK1,bool)),sK4))),s('type.realax.real',happ(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun(sK1,bool),sK3)))))) | s('type.num.num',sK5(sK4,sK2,sK1)) != s('type.num.num',sK6(sK4,sK2,sK1)) | ~p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))))),
  inference(forward_demodulation,[],[f1577,f266])).
fof(f266,plain,(
  s(fun(sK1,bool),sK3) = s(fun(sK1,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(sK1,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(sK1,bool)),sK4),s(fun('type.num.num',bool),'const.pred_set.UNIV_0')))))),
  inference(cnf_transformation,[],[f172])).
fof(f1577,plain,(
  p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun('type.num.num',fun(sK1,bool)),sK4))),s('type.realax.real',happ(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun(sK1,bool),sK3)))))) | ~p(s(bool,'const.bool.IN_2'(s(fun(sK1,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(sK1,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(sK1,bool)),sK4),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(sK1,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2)))))) | s('type.num.num',sK5(sK4,sK2,sK1)) != s('type.num.num',sK6(sK4,sK2,sK1)) | ~p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))))),
  inference(forward_demodulation,[],[f1496,f266])).
fof(f1496,plain,(
  p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun('type.num.num',fun(sK1,bool)),sK4))),s('type.realax.real',happ(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun(sK1,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(sK1,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(sK1,bool)),sK4),s(fun('type.num.num',bool),'const.pred_set.UNIV_0')))))))))) | ~p(s(bool,'const.bool.IN_2'(s(fun(sK1,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(sK1,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(sK1,bool)),sK4),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(sK1,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2)))))) | s('type.num.num',sK5(sK4,sK2,sK1)) != s('type.num.num',sK6(sK4,sK2,sK1)) | ~p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))))),
  inference(resolution,[],[f264,f316])).
fof(f316,plain,(
  ( ! [X0,X5,X1] : (p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun('type.num.num',fun(X0,bool)),X5))),s('type.realax.real',happ(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X5),s(fun('type.num.num',bool),'const.pred_set.UNIV_0')))))))))) | ~p(s(bool,'const.bool.IN_2'(s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X5),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))) | s('type.num.num',sK5(X5,X1,X0)) != s('type.num.num',sK6(X5,X1,X0)) | ~p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X0,bool)),X5),s(fun(fun('type.num.num',fun(X0,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))))) | ~p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))))) )),
  inference(cnf_transformation,[],[f194])).
fof(f194,plain,(
  ! [X0,X1] : ((~p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))) | ! [X5] : (~p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X0,bool)),X5),s(fun(fun('type.num.num',fun(X0,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))))) | (s('type.num.num',sK5(X5,X1,X0)) != s('type.num.num',sK6(X5,X1,X0)) & ~p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X5),s('type.num.num',sK5(X5,X1,X0)))),s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X5),s('type.num.num',sK6(X5,X1,X0)))))))) | ~p(s(bool,'const.bool.IN_2'(s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X5),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))) | p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun('type.num.num',fun(X0,bool)),X5))),s('type.realax.real',happ(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X5),s(fun('type.num.num',bool),'const.pred_set.UNIV_0')))))))))))) & ((p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X0,bool)),sK7(X1,X0)),s(fun(fun('type.num.num',fun(X0,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))))) & ! [X3,X4] : (s('type.num.num',X3) = s('type.num.num',X4) | p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),sK7(X1,X0)),s('type.num.num',X3))),s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),sK7(X1,X0)),s('type.num.num',X4))))))) & p(s(bool,'const.bool.IN_2'(s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),sK7(X1,X0)),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))) & ~p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun('type.num.num',fun(X0,bool)),sK7(X1,X0)))),s('type.realax.real',happ(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),sK7(X1,X0)),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))))))))) | p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))))))),
  inference(skolemisation,[status(esa),new_symbols(skolem,[sK5,sK6,sK7])],[f193])).
fof(f193,plain,(
  ! [X0,X1] : ((~p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))) | ! [X5] : (~p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X0,bool)),X5),s(fun(fun('type.num.num',fun(X0,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))))) | ? [X6,X7] : (s('type.num.num',X6) != s('type.num.num',X7) & ~p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X5),s('type.num.num',X6))),s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X5),s('type.num.num',X7))))))) | ~p(s(bool,'const.bool.IN_2'(s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X5),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))) | p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun('type.num.num',fun(X0,bool)),X5))),s('type.realax.real',happ(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X5),s(fun('type.num.num',bool),'const.pred_set.UNIV_0')))))))))))) & (? [X2] : (p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun(fun('type.num.num',fun(X0,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))))) & ! [X3,X4] : (s('type.num.num',X3) = s('type.num.num',X4) | p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X2),s('type.num.num',X3))),s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X2),s('type.num.num',X4))))))) & p(s(bool,'const.bool.IN_2'(s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))) & ~p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun('type.num.num',fun(X0,bool)),X2))),s('type.realax.real',happ(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))))))))) | p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))))))),
  inference(rectify,[],[f192])).
fof(f192,plain,(
  ! [X0,X1] : ((~p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))) | ! [X2] : (~p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun(fun('type.num.num',fun(X0,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))))) | ? [X3,X4] : (s('type.num.num',X3) != s('type.num.num',X4) & ~p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X2),s('type.num.num',X3))),s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X2),s('type.num.num',X4))))))) | ~p(s(bool,'const.bool.IN_2'(s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))) | p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun('type.num.num',fun(X0,bool)),X2))),s('type.realax.real',happ(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun('type.num.num',bool),'const.pred_set.UNIV_0')))))))))))) & (? [X2] : (p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun(fun('type.num.num',fun(X0,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))))) & ! [X3,X4] : (s('type.num.num',X3) = s('type.num.num',X4) | p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X2),s('type.num.num',X3))),s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X2),s('type.num.num',X4))))))) & p(s(bool,'const.bool.IN_2'(s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))) & ~p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun('type.num.num',fun(X0,bool)),X2))),s('type.realax.real',happ(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))))))))) | p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))))))),
  inference(nnf_transformation,[],[f154])).
fof(f154,plain,(
  ! [X0,X1] : (p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))) <=> ! [X2] : (~p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun(fun('type.num.num',fun(X0,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))))) | ? [X3,X4] : (s('type.num.num',X3) != s('type.num.num',X4) & ~p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X2),s('type.num.num',X3))),s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X2),s('type.num.num',X4))))))) | ~p(s(bool,'const.bool.IN_2'(s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))) | p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun('type.num.num',fun(X0,bool)),X2))),s('type.realax.real',happ(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))))))))))),
  inference(flattening,[],[f153])).
fof(f153,plain,(
  ! [X0,X1] : (p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))) <=> ! [X2] : ((~p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun(fun('type.num.num',fun(X0,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))))) | ? [X3,X4] : (s('type.num.num',X3) != s('type.num.num',X4) & ~p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X2),s('type.num.num',X3))),s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X2),s('type.num.num',X4))))))) | ~p(s(bool,'const.bool.IN_2'(s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))))))) | p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun('type.num.num',fun(X0,bool)),X2))),s('type.realax.real',happ(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))))))))))),
  inference(ennf_transformation,[],[f91])).
fof(f91,plain,(
  ! [X0,X1] : (p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))) <=> ! [X2] : ((p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun(fun('type.num.num',fun(X0,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))))) & ! [X3,X4] : (s('type.num.num',X3) != s('type.num.num',X4) => p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X2),s('type.num.num',X3))),s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X2),s('type.num.num',X4))))))) & p(s(bool,'const.bool.IN_2'(s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))))))) => p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun('type.num.num',fun(X0,bool)),X2))),s('type.realax.real',happ(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))))))))))),
  inference(flattening,[],[f90])).
fof(f90,plain,(
  ! [X0] : ! [X1] : (p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))) <=> ! [X2] : ((p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun(fun('type.num.num',fun(X0,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))))) & ! [X3,X4] : (~s('type.num.num',X3) = s('type.num.num',X4) => p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X2),s('type.num.num',X3))),s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X2),s('type.num.num',X4))))))) & p(s(bool,'const.bool.IN_2'(s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))))))) => p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun('type.num.num',fun(X0,bool)),X2))),s('type.realax.real',happ(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X2),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))))))))))),
  inference(rectify,[],[f43])).
fof(f43,axiom,(
  ! [X6] : ! [X7] : (p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X6,bool),'type.pair.prod'(fun(fun(X6,bool),bool),fun(fun(X6,bool),'type.realax.real'))),X7)))) <=> ! [X9] : ((p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X6,bool)),X9),s(fun(fun('type.num.num',fun(X6,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X6,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X6,bool),'type.pair.prod'(fun(fun(X6,bool),bool),fun(fun(X6,bool),'type.realax.real'))),X7)))))))) & ! [X10,X11] : (~s('type.num.num',X10) = s('type.num.num',X11) => p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X6,bool),happ(s(fun('type.num.num',fun(X6,bool)),X9),s('type.num.num',X10))),s(fun(X6,bool),happ(s(fun('type.num.num',fun(X6,bool)),X9),s('type.num.num',X11))))))) & p(s(bool,'const.bool.IN_2'(s(fun(X6,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X6,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X6,bool)),X9),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(X6,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X6,bool),'type.pair.prod'(fun(fun(X6,bool),bool),fun(fun(X6,bool),'type.realax.real'))),X7))))))) => p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X6,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X6,bool),'type.pair.prod'(fun(fun(X6,bool),bool),fun(fun(X6,bool),'type.realax.real'))),X7))),s(fun('type.num.num',fun(X6,bool)),X9))),s('type.realax.real',happ(s(fun(fun(X6,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X6,bool),'type.pair.prod'(fun(fun(X6,bool),bool),fun(fun(X6,bool),'type.realax.real'))),X7))),s(fun(X6,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X6,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X6,bool)),X9),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))))))))))),
  file('thm.measure.COUNTABLY_ADDITIVE','thm.measure.countably_additive_def')).
fof(f264,plain,(
  p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(sK1,bool)),sK4),s(fun(fun('type.num.num',fun(sK1,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(sK1,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))))))))),
  inference(cnf_transformation,[],[f172])).
fof(f5994,plain,(
  ~p(s(bool,'T_0')) | s('type.num.num',sK5(sK4,sK2,sK1)) = s('type.num.num',sK6(sK4,sK2,sK1))),
  inference(resolution,[],[f1588,f265])).
fof(f265,plain,(
  ( ! [X4,X5] : (p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',X4))),s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',X5)))))) | s('type.num.num',X4) = s('type.num.num',X5)) )),
  inference(cnf_transformation,[],[f172])).
fof(f1588,plain,(
  ~p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',sK5(sK4,sK2,sK1)))),s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',sK6(sK4,sK2,sK1))))))) | ~p(s(bool,'T_0'))),
  inference(global_subsumption,[],[f1587,f268])).
fof(f1587,plain,(
  ~p(s(bool,'T_0')) | p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun('type.num.num',fun(sK1,bool)),sK4))),s('type.realax.real',happ(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun(sK1,bool),sK3)))))) | ~p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',sK5(sK4,sK2,sK1)))),s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',sK6(sK4,sK2,sK1)))))))),
  inference(duplicate_literal_removal,[],[f1586])).
fof(f1586,plain,(
  ~p(s(bool,'T_0')) | ~p(s(bool,'T_0')) | p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun('type.num.num',fun(sK1,bool)),sK4))),s('type.realax.real',happ(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun(sK1,bool),sK3)))))) | ~p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',sK5(sK4,sK2,sK1)))),s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',sK6(sK4,sK2,sK1)))))))),
  inference(forward_demodulation,[],[f1585,f816])).
fof(f1585,plain,(
  ~p(s(bool,'T_0')) | p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun('type.num.num',fun(sK1,bool)),sK4))),s('type.realax.real',happ(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun(sK1,bool),sK3)))))) | ~p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',sK5(sK4,sK2,sK1)))),s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',sK6(sK4,sK2,sK1))))))) | ~p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))))),
  inference(forward_demodulation,[],[f1584,f1108])).
fof(f1584,plain,(
  ~p(s(bool,'const.bool.IN_2'(s(fun(sK1,bool),sK3),s(fun(fun(sK1,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2)))))) | p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun('type.num.num',fun(sK1,bool)),sK4))),s('type.realax.real',happ(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun(sK1,bool),sK3)))))) | ~p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',sK5(sK4,sK2,sK1)))),s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',sK6(sK4,sK2,sK1))))))) | ~p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))))),
  inference(forward_demodulation,[],[f1583,f266])).
fof(f1583,plain,(
  p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun('type.num.num',fun(sK1,bool)),sK4))),s('type.realax.real',happ(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun(sK1,bool),sK3)))))) | ~p(s(bool,'const.bool.IN_2'(s(fun(sK1,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(sK1,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(sK1,bool)),sK4),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(sK1,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2)))))) | ~p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',sK5(sK4,sK2,sK1)))),s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',sK6(sK4,sK2,sK1))))))) | ~p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))))),
  inference(forward_demodulation,[],[f1497,f266])).
fof(f1497,plain,(
  p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun('type.num.num',fun(sK1,bool)),sK4))),s('type.realax.real',happ(s(fun(fun(sK1,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))),s(fun(sK1,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(sK1,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(sK1,bool)),sK4),s(fun('type.num.num',bool),'const.pred_set.UNIV_0')))))))))) | ~p(s(bool,'const.bool.IN_2'(s(fun(sK1,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(sK1,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(sK1,bool)),sK4),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(sK1,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2)))))) | ~p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',sK5(sK4,sK2,sK1)))),s(fun(sK1,bool),happ(s(fun('type.num.num',fun(sK1,bool)),sK4),s('type.num.num',sK6(sK4,sK2,sK1))))))) | ~p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(sK1,bool),'type.pair.prod'(fun(fun(sK1,bool),bool),fun(fun(sK1,bool),'type.realax.real'))),sK2))))),
  inference(resolution,[],[f264,f317])).
fof(f317,plain,(
  ( ! [X0,X5,X1] : (p(s(bool,'const.seq.sums_2'(s(fun('type.num.num','type.realax.real'),'const.combin.o_2'(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun('type.num.num',fun(X0,bool)),X5))),s('type.realax.real',happ(s(fun(fun(X0,bool),'type.realax.real'),'const.measure.measure_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))),s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X5),s(fun('type.num.num',bool),'const.pred_set.UNIV_0')))))))))) | ~p(s(bool,'const.bool.IN_2'(s(fun(X0,bool),'const.pred_set.BIGUNION_1'(s(fun(fun(X0,bool),bool),'const.pred_set.IMAGE_2'(s(fun('type.num.num',fun(X0,bool)),X5),s(fun('type.num.num',bool),'const.pred_set.UNIV_0'))))),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))) | ~p(s(bool,'const.pred_set.DISJOINT_2'(s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X5),s('type.num.num',sK5(X5,X1,X0)))),s(fun(X0,bool),happ(s(fun('type.num.num',fun(X0,bool)),X5),s('type.num.num',sK6(X5,X1,X0))))))) | ~p(s(bool,'const.bool.IN_2'(s(fun('type.num.num',fun(X0,bool)),X5),s(fun(fun('type.num.num',fun(X0,bool)),bool),'const.util_prob.FUNSET_2'(s(fun('type.num.num',bool),'const.pred_set.UNIV_0'),s(fun(fun(X0,bool),bool),'const.measure.measurable_sets_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1)))))))) | ~p(s(bool,'const.measure.countably_additive_1'(s('type.pair.prod'(fun(X0,bool),'type.pair.prod'(fun(fun(X0,bool),bool),fun(fun(X0,bool),'type.realax.real'))),X1))))) )),
  inference(cnf_transformation,[],[f194])).
% SZS output end Proof for thm.measure
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Refutation

% Active clauses: 137
% Passive clauses: 643
% Generated clauses: 5377
% Final active clauses: 133
% Final passive clauses: 590
% Input formulas: 53
% Initial clauses: 366
% 
% Duplicate literals: 512
% Trivial inequalities: 51
% Fw demodulations: 516
% Bw demodulations: 4
% Condensations: 510
% Global subsumptions: 4
% 
% Simple tautologies: 528
% Equational tautologies: 1
% Forward subsumptions: 3061
% 
% Binary resolution: 1928
% Forward superposition: 1476
% Backward superposition: 620
% Equality resolution: 4
% 
% SAT solver clauses: 661
% SAT solver unit clauses: 32
% SAT solver binary clauses: 150
% SAT solver learnt clauses: 8
% SAT solver learnt literals: 12
% 
% TWLsolver clauses: 647
% TWLsolver calls for satisfiability: 11499
% 
% Memory used [KB]: 5628
% Time elapsed: 0.162 s
% ------------------------------
% ------------------------------
% Success in time 19.211 s
