Hi Geoff, go and have some cold beer while I am trying to solve this very hard problem!
% remaining time: 299 next slice time: 5
dis+11_7_3 on thm.frac
% Refutation found. Thanks to Tanya!
% SZS status Theorem for thm.frac
% SZS output start Proof for thm.frac
fof(f10019,plain,(
  $false),
  inference(sat_splitting_refutation,[],[f10018,f202,f366,f203,f367,f201,f370,f200,f368,f372])).
fof(f372,plain,(
  s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',sK12))) != s('type.integer.int','const.integer.int_neg_1'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))))) | $spl7),
  inference(cnf_transformation,[],[f372_D])).
fof(f372_D,plain,(
  s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',sK12))) != s('type.integer.int','const.integer.int_neg_1'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))))) <=> ~$spl7),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl7])])).
fof(f368,plain,(
  p(s(bool,sK13)) | $spl2),
  inference(cnf_transformation,[],[f368_D])).
fof(f368_D,plain,(
  p(s(bool,sK13)) <=> ~$spl2),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl2])])).
fof(f200,plain,(
  p(s(bool,sK13)) | s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',sK12))) != s('type.integer.int','const.integer.int_neg_1'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0')))))))))),
  inference(cnf_transformation,[],[f131])).
fof(f131,plain,(
  (s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',sK12))) != s('type.integer.int','const.integer.int_neg_1'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))))) | p(s(bool,sK13))) & (s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',sK12))) != s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.num.|48|_0'))) | p(s(bool,sK13))) & (s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',sK12))) != s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))) | p(s(bool,sK13))) & ~p(s(bool,sK13))),
  inference(skolemisation,[status(esa),new_symbols(skolem,[sK12,sK13])],[f90])).
fof(f90,plain,(
  ? [X0,X1] : ((s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) != s('type.integer.int','const.integer.int_neg_1'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))))) | p(s(bool,X1))) & (s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.num.|48|_0'))) != s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) | p(s(bool,X1))) & (s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) != s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))) | p(s(bool,X1))) & ~p(s(bool,X1)))),
  inference(flattening,[],[f89])).
fof(f89,plain,(
  ? [X0,X1] : (((s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) != s('type.integer.int','const.integer.int_neg_1'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))))) | p(s(bool,X1))) & (s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.num.|48|_0'))) != s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) | p(s(bool,X1))) & (s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) != s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))) | p(s(bool,X1)))) & ~p(s(bool,X1)))),
  inference(ennf_transformation,[],[f37])).
fof(f37,plain,(
  ~! [X0,X1] : (((s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) = s('type.integer.int','const.integer.int_neg_1'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))))) => p(s(bool,X1))) & (s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.num.|48|_0'))) = s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) => p(s(bool,X1))) & (s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) = s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))) => p(s(bool,X1)))) => p(s(bool,X1)))),
  inference(rectify,[],[f6])).
fof(f6,negated_conjecture,(
  ~! [X6,X7] : (((s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X6))) = s('type.integer.int','const.integer.int_neg_1'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))))) => p(s(bool,X7))) & (s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.num.|48|_0'))) = s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X6))) => p(s(bool,X7))) & (s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X6))) = s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))) => p(s(bool,X7)))) => p(s(bool,X7)))),
  inference(negated_conjecture,[],[f5])).
fof(f5,conjecture,(
  ! [X6,X7] : (((s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X6))) = s('type.integer.int','const.integer.int_neg_1'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))))) => p(s(bool,X7))) & (s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.num.|48|_0'))) = s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X6))) => p(s(bool,X7))) & (s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X6))) = s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))) => p(s(bool,X7)))) => p(s(bool,X7)))),
  file('thm.frac.FRAC_SGN_CASES','thm.frac.FRAC_SGN_CASES')).
fof(f370,plain,(
  s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',sK12))) != s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.num.|48|_0'))) | $spl5),
  inference(cnf_transformation,[],[f370_D])).
fof(f370_D,plain,(
  s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',sK12))) != s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.num.|48|_0'))) <=> ~$spl5),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl5])])).
fof(f201,plain,(
  p(s(bool,sK13)) | s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',sK12))) != s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.num.|48|_0')))),
  inference(cnf_transformation,[],[f131])).
fof(f367,plain,(
  ~p(s(bool,sK13)) | $spl3),
  inference(cnf_transformation,[],[f367_D])).
fof(f367_D,plain,(
  ~p(s(bool,sK13)) <=> ~$spl3),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl3])])).
fof(f203,plain,(
  ~p(s(bool,sK13))),
  inference(cnf_transformation,[],[f131])).
fof(f366,plain,(
  s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',sK12))) != s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))) | $spl1),
  inference(cnf_transformation,[],[f366_D])).
fof(f366_D,plain,(
  s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',sK12))) != s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))) <=> ~$spl1),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl1])])).
fof(f202,plain,(
  p(s(bool,sK13)) | s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',sK12))) != s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0')))))))),
  inference(cnf_transformation,[],[f131])).
fof(f10018,plain,(
  $false | ($spl1 | $spl5 | $spl7)),
  inference(subsumption_resolution,[],[f10017,f366])).
fof(f10017,plain,(
  s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',sK12))) = s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))) | ($spl5 | $spl7)),
  inference(subsumption_resolution,[],[f10013,f370])).
fof(f10013,plain,(
  s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',sK12))) = s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.num.|48|_0'))) | s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',sK12))) = s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))) | $spl7),
  inference(equality_resolution,[],[f5271])).
fof(f5271,plain,(
  ( ! [X0] : (s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',sK12))) != s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) | s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.num.|48|_0'))) = s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) | s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) = s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0')))))))) ) | $spl7),
  inference(superposition,[],[f372,f213])).
fof(f213,plain,(
  ( ! [X0] : (s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) = s('type.integer.int','const.integer.int_neg_1'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))))) | s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.num.|48|_0'))) = s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) | s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) = s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0')))))))) )),
  inference(cnf_transformation,[],[f43])).
fof(f43,plain,(
  ! [X0] : (s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) = s('type.integer.int','const.integer.int_neg_1'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))))) | s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.num.|48|_0'))) = s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) | s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X0))) = s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))))),
  inference(rectify,[],[f26])).
fof(f26,axiom,(
  ! [X6] : (s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X6))) = s('type.integer.int','const.integer.int_neg_1'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))))) | s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.num.|48|_0'))) = s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X6))) | s('type.integer.int','const.frac.frac_sgn_1'(s('type.frac.frac',X6))) = s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num','const.arithmetic.NUMERAL_1'(s('type.num.num','const.arithmetic.BIT|49|_1'(s('type.num.num','const.arithmetic.ZERO_0'))))))))),
  file('thm.frac.FRAC_SGN_CASES','thm.frac.FRAC_SGN_TOTAL')).
% SZS output end Proof for thm.frac
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Refutation

% Active clauses: 493
% Passive clauses: 2835
% Generated clauses: 9742
% Final active clauses: 456
% Final passive clauses: 2004
% Input formulas: 35
% Initial clauses: 161
% 
% Duplicate literals: 293
% Trivial inequalities: 49
% Fw subsumption resolutions: 1095
% Fw demodulations: 420
% Bw demodulations: 35
% 
% Simple tautologies: 166
% Equational tautologies: 45
% Forward subsumptions: 4691
% 
% Binary resolution: 4172
% Factoring: 1145
% Forward superposition: 634
% Backward superposition: 1556
% Self superposition: 31
% Equality factoring: 32
% Equality resolution: 13
% 
% Split clauses: 236
% Split components: 479
% SAT solver clauses: 403
% SAT solver unit clauses: 8
% SAT solver binary clauses: 77
% SAT solver learnt clauses: 1
% 
% Sat splits: 236
% Sat splitting refutations: 4
% 
% TWLsolver clauses: 400
% TWLsolver calls for satisfiability: 200
% 
% Memory used [KB]: 3965
% Time elapsed: 0.193 s
% ------------------------------
% ------------------------------
% Success in time 0.195 s
