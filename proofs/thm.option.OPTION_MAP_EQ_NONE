Hi Geoff, go and have some cold beer while I am trying to solve this very hard problem!
% remaining time: 299 next slice time: 5
dis+11_7_3 on thm.option
% (79970)Time limit reached!
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Time limit
% Termination phase: Saturation

% Active clauses: 179
% Passive clauses: 3061
% Generated clauses: 27442
% Final active clauses: 160
% Final passive clauses: 2644
% Input formulas: 38
% Initial clauses: 53
% 
% Duplicate literals: 759
% Trivial inequalities: 584
% Fw subsumption resolutions: 3408
% Fw demodulations: 4448
% Bw demodulations: 13
% 
% Simple tautologies: 496
% Equational tautologies: 51
% Forward subsumptions: 14239
% Fw demodulations to eq. taut.: 84
% Bw demodulations to eq. taut.: 1
% 
% Binary resolution: 195
% Factoring: 1
% Forward superposition: 9095
% Backward superposition: 8492
% Self superposition: 172
% Equality factoring: 92
% Equality resolution: 52
% 
% Split clauses: 162
% Split components: 326
% SAT solver clauses: 448
% SAT solver unit clauses: 40
% SAT solver binary clauses: 193
% SAT solver learnt clauses: 1
% SAT solver learnt literals: 1
% 
% Sat splits: 162
% Sat splitting refutations: 8
% 
% TWLsolver clauses: 447
% TWLsolver calls for satisfiability: 132
% 
% Memory used [KB]: 15223
% Time elapsed: 0.600 s
% ------------------------------
% ------------------------------
% remaining time: 293 next slice time: 6
lrs-11_2_cond=on:fde=unused:gs=on:nwc=3:stl=30:sdd=off:sfr=on:ssfp=100000:ssfq=1.4:smm=sco:ssnc=all_4 on thm.option
% (79981)Time limit reached!
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Time limit
% Termination phase: Saturation

% Active clauses: 224
% Passive clauses: 1604
% Generated clauses: 15743
% Final active clauses: 153
% Final passive clauses: 958
% Input formulas: 38
% Initial clauses: 53
% 
% Duplicate literals: 218
% Trivial inequalities: 410
% Fw subsumption resolutions: 789
% Fw demodulations: 3180
% Bw demodulations: 439
% Condensations: 387
% Global subsumptions: 5
% 
% Simple tautologies: 108
% Equational tautologies: 26
% Forward subsumptions: 6952
% Fw demodulations to eq. taut.: 60
% Bw demodulations to eq. taut.: 32
% 
% Binary resolution: 184
% Factoring: 1
% Forward superposition: 4687
% Backward superposition: 3230
% Self superposition: 102
% Equality factoring: 34
% Equality resolution: 97
% 
% Split clauses: 45
% Split components: 92
% SAT solver clauses: 2022
% SAT solver unit clauses: 80
% SAT solver binary clauses: 51
% SAT solver learnt clauses: 11
% SAT solver learnt literals: 1
% 
% Sat splits: 45
% Sat splitting refutations: 14
% 
% TWLsolver clauses: 2001
% TWLsolver calls for satisfiability: 340
% 
% Memory used [KB]: 15479
% Time elapsed: 0.700 s
% ------------------------------
% ------------------------------
% remaining time: 286 next slice time: 103
lrs+11_2_br=off:cond=on:fde=none:gs=on:gsaa=full_model:lwlo=on:nwc=2:sas=minisat:stl=30:ssfp=100000:ssfq=1.4:smm=sco:ssnc=none:sp=occurrence:urr=on_98 on thm.option
% Refutation found. Thanks to Tanya!
% SZS status Theorem for thm.option
% SZS output start Proof for thm.option
fof(f8671,plain,(
  $false),
  inference(sat_splitting_refutation,[],[f126,f182,f180,f125,f181,f179,f185,f2748,f2750,f2749,f8668,f8655,f8669])).
fof(f8669,plain,(
  $false | ($spl0 | $spl3)),
  inference(trivial_inequality_removal,[],[f8660])).
fof(f8660,plain,(
  s('type.option.option'('type.option.option'(sK0)),'const.option.SOME_1'(s('type.option.option'(sK0),'const.option.NONE_0'))) != s('type.option.option'('type.option.option'(sK0)),'const.option.SOME_1'(s('type.option.option'(sK0),'const.option.NONE_0'))) | ($spl0 | $spl3)),
  inference(unit_resulting_resolution,[],[f8641,f941])).
fof(f941,plain,(
  ( ! [X0] : (s('type.option.option'('type.option.option'(sK0)),'const.option.SOME_1'(s('type.option.option'(sK0),'const.option.NONE_0'))) != s('type.option.option'('type.option.option'(sK0)),'const.option.SOME_1'(s('type.option.option'(sK0),X0))) | s('type.option.option'(sK0),X0) = s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK2),s('type.option.option'(sK1),sK3)))) ) | $spl0),
  inference(superposition,[],[f165,f179])).
fof(f165,plain,(
  ( ! [X2,X0,X1] : (s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1))) != s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))) | s(X0,X1) = s(X0,X2)) )),
  inference(cnf_transformation,[],[f123])).
fof(f123,plain,(
  ! [X0,X1,X2] : ((s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1))) != s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))) | s(X0,X1) = s(X0,X2)) & (s(X0,X1) != s(X0,X2) | s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1))) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2)))))),
  inference(nnf_transformation,[],[f85])).
fof(f85,plain,(
  ! [X0,X1,X2] : (s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1))) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))) <=> s(X0,X1) = s(X0,X2))),
  inference(flattening,[],[f84])).
fof(f84,plain,(
  ! [X0] : ! [X1,X2] : (s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1))) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))) <=> s(X0,X1) = s(X0,X2))),
  inference(rectify,[],[f19])).
fof(f19,axiom,(
  ! [X7] : ! [X9,X14] : (s('type.option.option'(X7),'const.option.SOME_1'(s(X7,X9))) = s('type.option.option'(X7),'const.option.SOME_1'(s(X7,X14))) <=> s(X7,X9) = s(X7,X14))),
  file('thm.option.OPTION_MAP_EQ_NONE','thm.option.SOME_|49||49|')).
fof(f8641,plain,(
  ( ! [X17,X16] : (s('type.option.option'(X16),'const.option.NONE_0') != s('type.option.option'(X16),'const.option.OPTION_MAP_2'(s(fun(sK1,X16),X17),s('type.option.option'(sK1),sK3)))) ) | $spl3),
  inference(superposition,[],[f3201,f1640])).
fof(f1640,plain,(
  s('type.option.option'(sK1),sK3) = s('type.option.option'(sK1),'const.option.SOME_1'(s(sK1,sK4(sK3,sK1)))) | $spl3),
  inference(unit_resulting_resolution,[],[f182,f154])).
fof(f154,plain,(
  ( ! [X0,X1] : (s('type.option.option'(X0),X1) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,sK4(X1,X0)))) | s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1)) )),
  inference(cnf_transformation,[],[f119])).
fof(f119,plain,(
  ! [X0,X1] : (s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1) | s('type.option.option'(X0),X1) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,sK4(X1,X0)))))),
  inference(skolemisation,[status(esa),new_symbols(skolem,[sK4])],[f69])).
fof(f69,plain,(
  ! [X0,X1] : (s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1) | ? [X2] : s('type.option.option'(X0),X1) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))))),
  inference(flattening,[],[f68])).
fof(f68,plain,(
  ! [X0] : ! [X1] : (s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1) | ? [X2] : s('type.option.option'(X0),X1) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))))),
  inference(rectify,[],[f18])).
fof(f18,axiom,(
  ! [X7] : ! [X13] : (s('type.option.option'(X7),'const.option.NONE_0') = s('type.option.option'(X7),X13) | ? [X9] : s('type.option.option'(X7),X13) = s('type.option.option'(X7),'const.option.SOME_1'(s(X7,X9))))),
  file('thm.option.OPTION_MAP_EQ_NONE','thm.option.option_nchotomy')).
fof(f3201,plain,(
  ( ! [X10,X8,X11,X9] : (s('type.option.option'(X8),'const.option.NONE_0') != s('type.option.option'(X8),'const.option.OPTION_MAP_2'(s(fun(X9,X8),X10),s('type.option.option'(X9),'const.option.SOME_1'(s(X9,X11)))))) )),
  inference(superposition,[],[f162,f173])).
fof(f173,plain,(
  ( ! [X2,X0,X3,X1] : (s('type.option.option'(X0),'const.option.SOME_1'(s(X0,happ(s(fun(X1,X0),X2),s(X1,X3))))) = s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X2),s('type.option.option'(X1),'const.option.SOME_1'(s(X1,X3)))))) )),
  inference(cnf_transformation,[],[f92])).
fof(f92,plain,(
  ! [X0,X1,X2,X3] : s('type.option.option'(X0),'const.option.SOME_1'(s(X0,happ(s(fun(X1,X0),X2),s(X1,X3))))) = s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X2),s('type.option.option'(X1),'const.option.SOME_1'(s(X1,X3)))))),
  inference(flattening,[],[f91])).
fof(f91,plain,(
  ! [X0,X1] : ! [X2,X3] : s('type.option.option'(X0),'const.option.SOME_1'(s(X0,happ(s(fun(X1,X0),X2),s(X1,X3))))) = s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X2),s('type.option.option'(X1),'const.option.SOME_1'(s(X1,X3)))))),
  inference(rectify,[],[f35])).
fof(f35,axiom,(
  ! [X6,X7] : ! [X18,X9] : s('type.option.option'(X6),'const.option.SOME_1'(s(X6,happ(s(fun(X7,X6),X18),s(X7,X9))))) = s('type.option.option'(X6),'const.option.OPTION_MAP_2'(s(fun(X7,X6),X18),s('type.option.option'(X7),'const.option.SOME_1'(s(X7,X9)))))),
  file('thm.option.OPTION_MAP_EQ_NONE','thm.option.option_CLAUSES|split|16')).
fof(f162,plain,(
  ( ! [X0,X1] : (s('type.option.option'(X0),'const.option.NONE_0') != s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1)))) )),
  inference(cnf_transformation,[],[f79])).
fof(f79,plain,(
  ! [X0,X1] : s('type.option.option'(X0),'const.option.NONE_0') != s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1)))),
  inference(flattening,[],[f78])).
fof(f78,plain,(
  ! [X0] : ! [X1] : ~s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1)))),
  inference(rectify,[],[f21])).
fof(f21,axiom,(
  ! [X7] : ! [X9] : ~s('type.option.option'(X7),'const.option.NONE_0') = s('type.option.option'(X7),'const.option.SOME_1'(s(X7,X9)))),
  file('thm.option.OPTION_MAP_EQ_NONE','thm.option.NOT_NONE_SOME')).
fof(f8655,plain,(
  $false | ($spl0 | $spl3)),
  inference(unit_resulting_resolution,[],[f179,f8641])).
fof(f8668,plain,(
  $false | ($spl0 | $spl3)),
  inference(trivial_inequality_removal,[],[f8667])).
fof(f8667,plain,(
  s('type.option.option'(sK0),'const.option.NONE_0') != s('type.option.option'(sK0),'const.option.NONE_0') | ($spl0 | $spl3)),
  inference(superposition,[],[f8641,f179])).
fof(f2749,plain,(
  ( ! [X5] : (s(bool,'T_0') = s(bool,X5)) ) | $spl4),
  inference(cnf_transformation,[],[f2749_D])).
fof(f2749_D,plain,(
  ( ! [X5] : (s(bool,'T_0') = s(bool,X5)) ) <=> ~$spl4),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl4])])).
fof(f2750,plain,(
  ( ! [X6] : (s('type.option.option'(bool),'const.option.SOME_1'(s(bool,'F_0'))) = s('type.option.option'(bool),'const.option.option_CASE_3'(s('type.option.option'(bool),'const.option.SOME_1'(s(bool,'F_0'))),s('type.option.option'(bool),X6),s(fun(bool,'type.option.option'(bool)),'const.option.SOME_0')))) ) | $spl6),
  inference(cnf_transformation,[],[f2750_D])).
fof(f2750_D,plain,(
  ( ! [X6] : (s('type.option.option'(bool),'const.option.SOME_1'(s(bool,'F_0'))) = s('type.option.option'(bool),'const.option.option_CASE_3'(s('type.option.option'(bool),'const.option.SOME_1'(s(bool,'F_0'))),s('type.option.option'(bool),X6),s(fun(bool,'type.option.option'(bool)),'const.option.SOME_0')))) ) <=> ~$spl6),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl6])])).
fof(f2748,plain,(
  ( ! [X6,X5] : (s('type.option.option'(bool),'const.option.SOME_1'(s(bool,'F_0'))) = s('type.option.option'(bool),'const.option.option_CASE_3'(s('type.option.option'(bool),'const.option.SOME_1'(s(bool,'F_0'))),s('type.option.option'(bool),X6),s(fun(bool,'type.option.option'(bool)),'const.option.SOME_0'))) | s(bool,'T_0') = s(bool,X5)) ) | $spl3),
  inference(subsumption_resolution,[],[f2747,f127])).
fof(f127,plain,(
  p(s(bool,'T_0'))),
  inference(cnf_transformation,[],[f1])).
fof(f1,axiom,(
  p(s(bool,'T_0'))),
  file('thm.option.OPTION_MAP_EQ_NONE',aHL_TRUTH)).
fof(f2747,plain,(
  ( ! [X6,X5] : (~p(s(bool,'T_0')) | s('type.option.option'(bool),'const.option.SOME_1'(s(bool,'F_0'))) = s('type.option.option'(bool),'const.option.option_CASE_3'(s('type.option.option'(bool),'const.option.SOME_1'(s(bool,'F_0'))),s('type.option.option'(bool),X6),s(fun(bool,'type.option.option'(bool)),'const.option.SOME_0'))) | s(bool,'T_0') = s(bool,X5)) ) | $spl3),
  inference(forward_demodulation,[],[f2722,f148])).
fof(f148,plain,(
  ( ! [X0,X1] : (s(bool,'T_0') = s(bool,'const.option.IS_SOME_1'(s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1)))))) )),
  inference(cnf_transformation,[],[f57])).
fof(f57,plain,(
  ! [X0,X1] : s(bool,'T_0') = s(bool,'const.option.IS_SOME_1'(s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1)))))),
  inference(flattening,[],[f56])).
fof(f56,plain,(
  ! [X0] : ! [X1] : s(bool,'T_0') = s(bool,'const.option.IS_SOME_1'(s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1)))))),
  inference(rectify,[],[f23])).
fof(f23,axiom,(
  ! [X7] : ! [X9] : s(bool,'T_0') = s(bool,'const.option.IS_SOME_1'(s('type.option.option'(X7),'const.option.SOME_1'(s(X7,X9)))))),
  file('thm.option.OPTION_MAP_EQ_NONE','thm.option.IS_SOME_DEF|split|0')).
fof(f2722,plain,(
  ( ! [X6,X5] : (~p(s(bool,'const.option.IS_SOME_1'(s('type.option.option'(bool),'const.option.SOME_1'(s(bool,X5)))))) | s('type.option.option'(bool),'const.option.SOME_1'(s(bool,'F_0'))) = s('type.option.option'(bool),'const.option.option_CASE_3'(s('type.option.option'(bool),'const.option.SOME_1'(s(bool,'F_0'))),s('type.option.option'(bool),X6),s(fun(bool,'type.option.option'(bool)),'const.option.SOME_0'))) | s(bool,'T_0') = s(bool,X5)) ) | $spl3),
  inference(superposition,[],[f164,f1152])).
fof(f1152,plain,(
  ( ! [X0] : (s('type.option.option'(bool),'const.option.SOME_1'(s(bool,'F_0'))) = s('type.option.option'(bool),'const.option.SOME_1'(s(bool,X0))) | s(bool,'T_0') = s(bool,X0)) ) | $spl3),
  inference(condensation,[],[f1151])).
fof(f1151,plain,(
  ( ! [X8,X7] : (s('type.option.option'(bool),'const.option.SOME_1'(s(bool,'F_0'))) = s('type.option.option'(bool),'const.option.SOME_1'(s(bool,X8))) | s(bool,'T_0') = s(bool,X8) | s(bool,'T_0') = s(bool,X7)) ) | $spl3),
  inference(trivial_inequality_removal,[],[f1135])).
fof(f1135,plain,(
  ( ! [X8,X7] : (s(bool,X7) != s(bool,X7) | s('type.option.option'(bool),'const.option.SOME_1'(s(bool,'F_0'))) = s('type.option.option'(bool),'const.option.SOME_1'(s(bool,X8))) | s(bool,'T_0') = s(bool,X8) | s(bool,'T_0') = s(bool,X7)) ) | $spl3),
  inference(superposition,[],[f1082,f136])).
fof(f136,plain,(
  ( ! [X0] : (s(bool,'F_0') = s(bool,X0) | s(bool,'T_0') = s(bool,X0)) )),
  inference(cnf_transformation,[],[f3])).
fof(f3,axiom,(
  ! [X0] : (s(bool,'T_0') = s(bool,X0) | s(bool,'F_0') = s(bool,X0))),
  file('thm.option.OPTION_MAP_EQ_NONE',aHL_BOOL_CASES)).
fof(f1082,plain,(
  ( ! [X17,X16] : (s(bool,'F_0') != s(bool,X17) | s('type.option.option'(bool),'const.option.SOME_1'(s(bool,X16))) = s('type.option.option'(bool),'const.option.SOME_1'(s(bool,X17))) | s(bool,'T_0') = s(bool,X16)) ) | $spl3),
  inference(forward_demodulation,[],[f1042,f339])).
fof(f339,plain,(
  s(bool,'F_0') = s(bool,'const.option.IS_NONE_1'(s('type.option.option'(sK1),sK3))) | $spl3),
  inference(unit_resulting_resolution,[],[f312,f143])).
fof(f143,plain,(
  ( ! [X0] : (p(s(bool,X0)) | s(bool,'F_0') = s(bool,X0)) )),
  inference(cnf_transformation,[],[f116])).
fof(f116,plain,(
  ! [X0] : ((s(bool,'F_0') != s(bool,X0) | ~p(s(bool,X0))) & (p(s(bool,X0)) | s(bool,'F_0') = s(bool,X0)))),
  inference(nnf_transformation,[],[f51])).
fof(f51,plain,(
  ! [X0] : (s(bool,'F_0') = s(bool,X0) <=> ~p(s(bool,X0)))),
  inference(flattening,[],[f50])).
fof(f50,plain,(
  ! [X0] : (s(bool,'F_0') = s(bool,X0) <=> ~p(s(bool,X0)))),
  inference(rectify,[],[f17])).
fof(f17,axiom,(
  ! [X12] : (s(bool,'F_0') = s(bool,X12) <=> ~p(s(bool,X12)))),
  file('thm.option.OPTION_MAP_EQ_NONE','thm.bool.EQ_CLAUSES|split|3')).
fof(f312,plain,(
  ~p(s(bool,'const.option.IS_NONE_1'(s('type.option.option'(sK1),sK3)))) | $spl3),
  inference(unit_resulting_resolution,[],[f182,f158])).
fof(f158,plain,(
  ( ! [X0,X1] : (~p(s(bool,'const.option.IS_NONE_1'(s('type.option.option'(X0),X1)))) | s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1)) )),
  inference(cnf_transformation,[],[f121])).
fof(f121,plain,(
  ! [X0,X1] : ((~p(s(bool,'const.option.IS_NONE_1'(s('type.option.option'(X0),X1)))) | s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1)) & (s('type.option.option'(X0),'const.option.NONE_0') != s('type.option.option'(X0),X1) | p(s(bool,'const.option.IS_NONE_1'(s('type.option.option'(X0),X1))))))),
  inference(nnf_transformation,[],[f75])).
fof(f75,plain,(
  ! [X0,X1] : (p(s(bool,'const.option.IS_NONE_1'(s('type.option.option'(X0),X1)))) <=> s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1))),
  inference(flattening,[],[f74])).
fof(f74,plain,(
  ! [X0] : ! [X1] : (p(s(bool,'const.option.IS_NONE_1'(s('type.option.option'(X0),X1)))) <=> s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1))),
  inference(rectify,[],[f25])).
fof(f25,axiom,(
  ! [X7] : ! [X9] : (p(s(bool,'const.option.IS_NONE_1'(s('type.option.option'(X7),X9)))) <=> s('type.option.option'(X7),'const.option.NONE_0') = s('type.option.option'(X7),X9))),
  file('thm.option.OPTION_MAP_EQ_NONE','thm.option.IS_NONE_EQ_NONE')).
fof(f1042,plain,(
  ( ! [X17,X16] : (s(bool,X17) != s(bool,'const.option.IS_NONE_1'(s('type.option.option'(sK1),sK3))) | s('type.option.option'(bool),'const.option.SOME_1'(s(bool,X16))) = s('type.option.option'(bool),'const.option.SOME_1'(s(bool,X17))) | s(bool,'T_0') = s(bool,X16)) ) | $spl3),
  inference(superposition,[],[f166,f663])).
fof(f663,plain,(
  ( ! [X10] : (s(bool,X10) = s(bool,'const.option.IS_NONE_1'(s('type.option.option'(sK1),sK3))) | s(bool,'T_0') = s(bool,X10)) ) | $spl3),
  inference(subsumption_resolution,[],[f656,f183])).
fof(f183,plain,(
  ~p(s(bool,'F_0'))),
  inference(subsumption_resolution,[],[f130,f127])).
fof(f130,plain,(
  ~p(s(bool,'T_0')) | ~p(s(bool,'F_0'))),
  inference(cnf_transformation,[],[f112])).
fof(f112,plain,(
  (p(s(bool,'T_0')) | p(s(bool,'F_0'))) & (~p(s(bool,'F_0')) | ~p(s(bool,'T_0')))),
  inference(nnf_transformation,[],[f42])).
fof(f42,plain,(
  ~p(s(bool,'T_0')) <=> p(s(bool,'F_0'))),
  inference(flattening,[],[f11])).
fof(f11,axiom,(
  ~p(s(bool,'T_0')) <=> p(s(bool,'F_0'))),
  file('thm.option.OPTION_MAP_EQ_NONE','thm.bool.NOT_CLAUSES|split|1')).
fof(f656,plain,(
  ( ! [X10] : (p(s(bool,'F_0')) | s(bool,X10) = s(bool,'const.option.IS_NONE_1'(s('type.option.option'(sK1),sK3))) | s(bool,'T_0') = s(bool,X10)) ) | $spl3),
  inference(superposition,[],[f288,f339])).
fof(f288,plain,(
  ( ! [X8,X7] : (p(s(bool,X8)) | s(bool,X7) = s(bool,X8) | s(bool,'T_0') = s(bool,X7)) )),
  inference(subsumption_resolution,[],[f277,f183])).
fof(f277,plain,(
  ( ! [X8,X7] : (p(s(bool,'F_0')) | p(s(bool,X8)) | s(bool,X7) = s(bool,X8) | s(bool,'T_0') = s(bool,X7)) )),
  inference(superposition,[],[f167,f136])).
fof(f167,plain,(
  ( ! [X0,X1] : (p(s(bool,X1)) | p(s(bool,X0)) | s(bool,X0) = s(bool,X1)) )),
  inference(cnf_transformation,[],[f106])).
fof(f106,plain,(
  ! [X0,X1] : ((p(s(bool,X0)) & ~p(s(bool,X1))) | (p(s(bool,X1)) & ~p(s(bool,X0))) | s(bool,X0) = s(bool,X1))),
  inference(flattening,[],[f105])).
fof(f105,plain,(
  ! [X0,X1] : ((p(s(bool,X0)) & ~p(s(bool,X1))) | ((p(s(bool,X1)) & ~p(s(bool,X0))) | s(bool,X0) = s(bool,X1)))),
  inference(ennf_transformation,[],[f86])).
fof(f86,plain,(
  ! [X0,X1] : ((p(s(bool,X0)) => p(s(bool,X1))) => ((p(s(bool,X1)) => p(s(bool,X0))) => s(bool,X0) = s(bool,X1)))),
  inference(rectify,[],[f8])).
fof(f8,axiom,(
  ! [X10,X11] : ((p(s(bool,X10)) => p(s(bool,X11))) => ((p(s(bool,X11)) => p(s(bool,X10))) => s(bool,X10) = s(bool,X11)))),
  file('thm.option.OPTION_MAP_EQ_NONE','thm.bool.IMP_ANTISYM_AX')).
fof(f166,plain,(
  ( ! [X2,X0,X1] : (s(X0,X1) != s(X0,X2) | s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X1))) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2)))) )),
  inference(cnf_transformation,[],[f123])).
fof(f164,plain,(
  ( ! [X2,X0,X1] : (~p(s(bool,'const.option.IS_SOME_1'(s('type.option.option'(X0),X2)))) | s('type.option.option'(X0),X2) = s('type.option.option'(X0),'const.option.option_CASE_3'(s('type.option.option'(X0),X2),s('type.option.option'(X0),X1),s(fun(X0,'type.option.option'(X0)),'const.option.SOME_0')))) )),
  inference(cnf_transformation,[],[f104])).
fof(f104,plain,(
  ! [X0,X1,X2] : (~p(s(bool,'const.option.IS_SOME_1'(s('type.option.option'(X0),X2)))) | s('type.option.option'(X0),X2) = s('type.option.option'(X0),'const.option.option_CASE_3'(s('type.option.option'(X0),X2),s('type.option.option'(X0),X1),s(fun(X0,'type.option.option'(X0)),'const.option.SOME_0'))))),
  inference(ennf_transformation,[],[f83])).
fof(f83,plain,(
  ! [X0,X1,X2] : (p(s(bool,'const.option.IS_SOME_1'(s('type.option.option'(X0),X2)))) => s('type.option.option'(X0),X2) = s('type.option.option'(X0),'const.option.option_CASE_3'(s('type.option.option'(X0),X2),s('type.option.option'(X0),X1),s(fun(X0,'type.option.option'(X0)),'const.option.SOME_0'))))),
  inference(flattening,[],[f82])).
fof(f82,plain,(
  ! [X0] : ! [X1,X2] : (p(s(bool,'const.option.IS_SOME_1'(s('type.option.option'(X0),X2)))) => s('type.option.option'(X0),X2) = s('type.option.option'(X0),'const.option.option_CASE_3'(s('type.option.option'(X0),X2),s('type.option.option'(X0),X1),s(fun(X0,'type.option.option'(X0)),'const.option.SOME_0'))))),
  inference(rectify,[],[f32])).
fof(f32,axiom,(
  ! [X7] : ! [X16,X9] : (p(s(bool,'const.option.IS_SOME_1'(s('type.option.option'(X7),X9)))) => s('type.option.option'(X7),X9) = s('type.option.option'(X7),'const.option.option_CASE_3'(s('type.option.option'(X7),X9),s('type.option.option'(X7),X16),s(fun(X7,'type.option.option'(X7)),'const.option.SOME_0'))))),
  file('thm.option.OPTION_MAP_EQ_NONE','thm.option.option_CLAUSES|split|13')).
fof(f185,plain,(
  $false | ($spl1 | $spl2)),
  inference(subsumption_resolution,[],[f184,f171])).
fof(f171,plain,(
  ( ! [X2,X0,X1] : (s('type.option.option'(X1),'const.option.NONE_0') = s('type.option.option'(X1),'const.option.OPTION_MAP_2'(s(fun(X0,X1),X2),s('type.option.option'(X0),'const.option.NONE_0')))) )),
  inference(cnf_transformation,[],[f88])).
fof(f88,plain,(
  ! [X0,X1,X2] : s('type.option.option'(X1),'const.option.NONE_0') = s('type.option.option'(X1),'const.option.OPTION_MAP_2'(s(fun(X0,X1),X2),s('type.option.option'(X0),'const.option.NONE_0')))),
  inference(flattening,[],[f87])).
fof(f87,plain,(
  ! [X0,X1] : ! [X2] : s('type.option.option'(X1),'const.option.NONE_0') = s('type.option.option'(X1),'const.option.OPTION_MAP_2'(s(fun(X0,X1),X2),s('type.option.option'(X0),'const.option.NONE_0')))),
  inference(rectify,[],[f36])).
fof(f36,axiom,(
  ! [X7,X6] : ! [X18] : s('type.option.option'(X6),'const.option.NONE_0') = s('type.option.option'(X6),'const.option.OPTION_MAP_2'(s(fun(X7,X6),X18),s('type.option.option'(X7),'const.option.NONE_0')))),
  file('thm.option.OPTION_MAP_EQ_NONE','thm.option.option_CLAUSES|split|17')).
fof(f184,plain,(
  s('type.option.option'(sK0),'const.option.NONE_0') != s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK2),s('type.option.option'(sK1),'const.option.NONE_0'))) | ($spl1 | $spl2)),
  inference(forward_demodulation,[],[f180,f181])).
fof(f179,plain,(
  s('type.option.option'(sK0),'const.option.NONE_0') = s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK2),s('type.option.option'(sK1),sK3))) | $spl0),
  inference(cnf_transformation,[],[f179_D])).
fof(f179_D,plain,(
  s('type.option.option'(sK0),'const.option.NONE_0') = s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK2),s('type.option.option'(sK1),sK3))) <=> ~$spl0),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl0])])).
fof(f181,plain,(
  s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK3) | $spl2),
  inference(cnf_transformation,[],[f181_D])).
fof(f181_D,plain,(
  s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK3) <=> ~$spl2),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl2])])).
fof(f125,plain,(
  s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK3) | s('type.option.option'(sK0),'const.option.NONE_0') = s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK2),s('type.option.option'(sK1),sK3)))),
  inference(cnf_transformation,[],[f111])).
fof(f111,plain,(
  (s('type.option.option'(sK0),'const.option.NONE_0') = s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK2),s('type.option.option'(sK1),sK3))) | s('type.option.option'(sK1),'const.option.NONE_0') = s('type.option.option'(sK1),sK3)) & (s('type.option.option'(sK0),'const.option.NONE_0') != s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK2),s('type.option.option'(sK1),sK3))) | s('type.option.option'(sK1),'const.option.NONE_0') != s('type.option.option'(sK1),sK3))),
  inference(skolemisation,[status(esa),new_symbols(skolem,[sK0,sK1,sK2,sK3])],[f110])).
fof(f110,plain,(
  ? [X0,X1,X2,X3] : ((s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X2),s('type.option.option'(X1),X3))) | s('type.option.option'(X1),'const.option.NONE_0') = s('type.option.option'(X1),X3)) & (s('type.option.option'(X0),'const.option.NONE_0') != s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X2),s('type.option.option'(X1),X3))) | s('type.option.option'(X1),'const.option.NONE_0') != s('type.option.option'(X1),X3)))),
  inference(nnf_transformation,[],[f101])).
fof(f101,plain,(
  ? [X0,X1,X2,X3] : (s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X2),s('type.option.option'(X1),X3))) <~> s('type.option.option'(X1),'const.option.NONE_0') = s('type.option.option'(X1),X3))),
  inference(ennf_transformation,[],[f41])).
fof(f41,plain,(
  ~! [X0,X1,X2,X3] : (s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X2),s('type.option.option'(X1),X3))) <=> s('type.option.option'(X1),'const.option.NONE_0') = s('type.option.option'(X1),X3))),
  inference(flattening,[],[f40])).
fof(f40,plain,(
  ~! [X0,X1] : ! [X2,X3] : (s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),'const.option.OPTION_MAP_2'(s(fun(X1,X0),X2),s('type.option.option'(X1),X3))) <=> s('type.option.option'(X1),'const.option.NONE_0') = s('type.option.option'(X1),X3))),
  inference(rectify,[],[f6])).
fof(f6,negated_conjecture,(
  ~! [X6,X7] : ! [X8,X9] : (s('type.option.option'(X6),'const.option.NONE_0') = s('type.option.option'(X6),'const.option.OPTION_MAP_2'(s(fun(X7,X6),X8),s('type.option.option'(X7),X9))) <=> s('type.option.option'(X7),'const.option.NONE_0') = s('type.option.option'(X7),X9))),
  inference(negated_conjecture,[],[f5])).
fof(f5,conjecture,(
  ! [X6,X7] : ! [X8,X9] : (s('type.option.option'(X6),'const.option.NONE_0') = s('type.option.option'(X6),'const.option.OPTION_MAP_2'(s(fun(X7,X6),X8),s('type.option.option'(X7),X9))) <=> s('type.option.option'(X7),'const.option.NONE_0') = s('type.option.option'(X7),X9))),
  file('thm.option.OPTION_MAP_EQ_NONE','thm.option.OPTION_MAP_EQ_NONE')).
fof(f180,plain,(
  s('type.option.option'(sK0),'const.option.NONE_0') != s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK2),s('type.option.option'(sK1),sK3))) | $spl1),
  inference(cnf_transformation,[],[f180_D])).
fof(f180_D,plain,(
  s('type.option.option'(sK0),'const.option.NONE_0') != s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK2),s('type.option.option'(sK1),sK3))) <=> ~$spl1),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl1])])).
fof(f182,plain,(
  s('type.option.option'(sK1),'const.option.NONE_0') != s('type.option.option'(sK1),sK3) | $spl3),
  inference(cnf_transformation,[],[f182_D])).
fof(f182_D,plain,(
  s('type.option.option'(sK1),'const.option.NONE_0') != s('type.option.option'(sK1),sK3) <=> ~$spl3),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl3])])).
fof(f126,plain,(
  s('type.option.option'(sK1),'const.option.NONE_0') != s('type.option.option'(sK1),sK3) | s('type.option.option'(sK0),'const.option.NONE_0') != s('type.option.option'(sK0),'const.option.OPTION_MAP_2'(s(fun(sK1,sK0),sK2),s('type.option.option'(sK1),sK3)))),
  inference(cnf_transformation,[],[f111])).
% SZS output end Proof for thm.option
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Refutation

% Active clauses: 90
% Passive clauses: 368
% Generated clauses: 8456
% Final active clauses: 85
% Final passive clauses: 276
% Input formulas: 38
% Initial clauses: 53
% 
% Duplicate literals: 422
% Trivial inequalities: 94
% Fw subsumption resolutions: 497
% Fw demodulations: 1309
% Bw demodulations: 5
% Condensations: 541
% 
% Simple tautologies: 114
% Equational tautologies: 97
% Forward subsumptions: 4842
% Fw demodulations to eq. taut.: 165
% Bw demodulations to eq. taut.: 1
% 
% Unit resulting resolution: 475
% Factoring: 1
% Forward superposition: 2097
% Backward superposition: 2761
% Self superposition: 119
% Equality factoring: 67
% Equality resolution: 10
% 
% Split clauses: 3
% Split components: 6
% SAT solver clauses: 380
% SAT solver unit clauses: 42
% SAT solver binary clauses: 96
% 
% Sat splits: 3
% Sat splitting refutations: 4
% 
% Memory used [KB]: 5117
% Time elapsed: 0.283 s
% ------------------------------
% ------------------------------
% Success in time 1.61 s
