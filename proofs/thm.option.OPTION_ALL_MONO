Hi Geoff, go and have some cold beer while I am trying to solve this very hard problem!
% remaining time: 300 next slice time: 5
dis+11_7_3 on thm.option
% Refutation found. Thanks to Tanya!
% SZS status Theorem for thm.option
% SZS output start Proof for thm.option
fof(f20291,plain,(
  $false),
  inference(sat_splitting_refutation,[],[f20246,f57,f82,f59,f85,f346,f351,f349,f394,f95,f99,f97,f110,f20289,f19996,f20000,f19998])).
fof(f19998,plain,(
  s('type.option.option'(sK0),'const.option.NONE_0') = s('type.option.option'(sK0),sK1) | $spl492),
  inference(cnf_transformation,[],[f19998_D])).
fof(f19998_D,plain,(
  s('type.option.option'(sK0),'const.option.NONE_0') = s('type.option.option'(sK0),sK1) <=> ~$spl492),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl492])])).
fof(f20000,plain,(
  s(bool,'T_0') = s(bool,happ(s(fun(sK0,bool),sK3),s(sK0,sK4(sK1,sK0)))) | $spl494),
  inference(cnf_transformation,[],[f20000_D])).
fof(f20000_D,plain,(
  s(bool,'T_0') = s(bool,happ(s(fun(sK0,bool),sK3),s(sK0,sK4(sK1,sK0)))) <=> ~$spl494),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl494])])).
fof(f19996,plain,(
  s(bool,'T_0') = s(bool,happ(s(fun(sK0,bool),sK3),s(sK0,sK4(sK1,sK0)))) | s('type.option.option'(sK0),'const.option.NONE_0') = s('type.option.option'(sK0),sK1) | ($spl2 | $spl7)),
  inference(subsumption_resolution,[],[f19954,f82])).
fof(f19954,plain,(
  ~p(s(bool,'T_0')) | s(bool,'T_0') = s(bool,happ(s(fun(sK0,bool),sK3),s(sK0,sK4(sK1,sK0)))) | s('type.option.option'(sK0),'const.option.NONE_0') = s('type.option.option'(sK0),sK1) | $spl7),
  inference(superposition,[],[f1218,f96])).
fof(f96,plain,(
  s(bool,'T_0') = s(bool,'const.option.OPTION_ALL_2'(s(fun(sK0,bool),sK3),s('type.option.option'(sK0),sK1))) | $spl7),
  inference(subsumption_resolution,[],[f92,f85])).
fof(f92,plain,(
  p(s(bool,'F_0')) | s(bool,'T_0') = s(bool,'const.option.OPTION_ALL_2'(s(fun(sK0,bool),sK3),s('type.option.option'(sK0),sK1)))),
  inference(superposition,[],[f55,f60])).
fof(f60,plain,(
  ( ! [X0] : (s(bool,'F_0') = s(bool,X0) | s(bool,'T_0') = s(bool,X0)) )),
  inference(cnf_transformation,[],[f3])).
fof(f3,axiom,(
  ! [X0] : (s(bool,'T_0') = s(bool,X0) | s(bool,'F_0') = s(bool,X0))),
  file('thm.option.OPTION_ALL_MONO',aHL_BOOL_CASES)).
fof(f55,plain,(
  p(s(bool,'const.option.OPTION_ALL_2'(s(fun(sK0,bool),sK3),s('type.option.option'(sK0),sK1))))),
  inference(cnf_transformation,[],[f41])).
fof(f41,plain,(
  ! [X4] : (~p(s(bool,happ(s(fun(sK0,bool),sK3),s(sK0,X4)))) | p(s(bool,happ(s(fun(sK0,bool),sK2),s(sK0,X4))))) & p(s(bool,'const.option.OPTION_ALL_2'(s(fun(sK0,bool),sK3),s('type.option.option'(sK0),sK1)))) & ~p(s(bool,'const.option.OPTION_ALL_2'(s(fun(sK0,bool),sK2),s('type.option.option'(sK0),sK1))))),
  inference(skolemisation,[status(esa),new_symbols(skolem,[sK0,sK1,sK2,sK3])],[f34])).
fof(f34,plain,(
  ? [X0,X1,X2,X3] : (! [X4] : (~p(s(bool,happ(s(fun(X0,bool),X3),s(X0,X4)))) | p(s(bool,happ(s(fun(X0,bool),X2),s(X0,X4))))) & p(s(bool,'const.option.OPTION_ALL_2'(s(fun(X0,bool),X3),s('type.option.option'(X0),X1)))) & ~p(s(bool,'const.option.OPTION_ALL_2'(s(fun(X0,bool),X2),s('type.option.option'(X0),X1)))))),
  inference(flattening,[],[f33])).
fof(f33,plain,(
  ? [X0,X1,X2,X3] : (! [X4] : (~p(s(bool,happ(s(fun(X0,bool),X3),s(X0,X4)))) | p(s(bool,happ(s(fun(X0,bool),X2),s(X0,X4))))) & (p(s(bool,'const.option.OPTION_ALL_2'(s(fun(X0,bool),X3),s('type.option.option'(X0),X1)))) & ~p(s(bool,'const.option.OPTION_ALL_2'(s(fun(X0,bool),X2),s('type.option.option'(X0),X1))))))),
  inference(ennf_transformation,[],[f17])).
fof(f17,plain,(
  ~! [X0,X1,X2,X3] : (! [X4] : (p(s(bool,happ(s(fun(X0,bool),X3),s(X0,X4)))) => p(s(bool,happ(s(fun(X0,bool),X2),s(X0,X4))))) => (p(s(bool,'const.option.OPTION_ALL_2'(s(fun(X0,bool),X3),s('type.option.option'(X0),X1)))) => p(s(bool,'const.option.OPTION_ALL_2'(s(fun(X0,bool),X2),s('type.option.option'(X0),X1))))))),
  inference(flattening,[],[f16])).
fof(f16,plain,(
  ~! [X0] : ! [X1,X2,X3] : (! [X4] : (p(s(bool,happ(s(fun(X0,bool),X3),s(X0,X4)))) => p(s(bool,happ(s(fun(X0,bool),X2),s(X0,X4))))) => (p(s(bool,'const.option.OPTION_ALL_2'(s(fun(X0,bool),X3),s('type.option.option'(X0),X1)))) => p(s(bool,'const.option.OPTION_ALL_2'(s(fun(X0,bool),X2),s('type.option.option'(X0),X1))))))),
  inference(rectify,[],[f6])).
fof(f6,negated_conjecture,(
  ~! [X6] : ! [X7,X8,X9] : (! [X10] : (p(s(bool,happ(s(fun(X6,bool),X9),s(X6,X10)))) => p(s(bool,happ(s(fun(X6,bool),X8),s(X6,X10))))) => (p(s(bool,'const.option.OPTION_ALL_2'(s(fun(X6,bool),X9),s('type.option.option'(X6),X7)))) => p(s(bool,'const.option.OPTION_ALL_2'(s(fun(X6,bool),X8),s('type.option.option'(X6),X7))))))),
  inference(negated_conjecture,[],[f5])).
fof(f5,conjecture,(
  ! [X6] : ! [X7,X8,X9] : (! [X10] : (p(s(bool,happ(s(fun(X6,bool),X9),s(X6,X10)))) => p(s(bool,happ(s(fun(X6,bool),X8),s(X6,X10))))) => (p(s(bool,'const.option.OPTION_ALL_2'(s(fun(X6,bool),X9),s('type.option.option'(X6),X7)))) => p(s(bool,'const.option.OPTION_ALL_2'(s(fun(X6,bool),X8),s('type.option.option'(X6),X7))))))),
  file('thm.option.OPTION_ALL_MONO','thm.option.OPTION_ALL_MONO')).
fof(f1218,plain,(
  ( ! [X24,X23,X22] : (~p(s(bool,'const.option.OPTION_ALL_2'(s(fun(X22,bool),X23),s('type.option.option'(X22),X24)))) | s(bool,'T_0') = s(bool,happ(s(fun(X22,bool),X23),s(X22,sK4(X24,X22)))) | s('type.option.option'(X22),'const.option.NONE_0') = s('type.option.option'(X22),X24)) ) | $spl7),
  inference(superposition,[],[f90,f472])).
fof(f472,plain,(
  ( ! [X2,X0,X1] : (s(bool,'const.option.OPTION_ALL_2'(s(fun(X0,bool),X2),s('type.option.option'(X0),X1))) = s(bool,happ(s(fun(X0,bool),X2),s(X0,sK4(X1,X0)))) | s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1)) )),
  inference(superposition,[],[f78,f77])).
fof(f77,plain,(
  ( ! [X0,X1] : (s('type.option.option'(X0),X1) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,sK4(X1,X0)))) | s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1)) )),
  inference(cnf_transformation,[],[f52])).
fof(f52,plain,(
  ! [X0,X1] : (s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1) | s('type.option.option'(X0),X1) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,sK4(X1,X0)))))),
  inference(skolemisation,[status(esa),new_symbols(skolem,[sK4])],[f28])).
fof(f28,plain,(
  ! [X0,X1] : (s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1) | ? [X2] : s('type.option.option'(X0),X1) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))))),
  inference(flattening,[],[f27])).
fof(f27,plain,(
  ! [X0] : ! [X1] : (s('type.option.option'(X0),'const.option.NONE_0') = s('type.option.option'(X0),X1) | ? [X2] : s('type.option.option'(X0),X1) = s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2))))),
  inference(rectify,[],[f13])).
fof(f13,axiom,(
  ! [X6] : ! [X7] : (s('type.option.option'(X6),'const.option.NONE_0') = s('type.option.option'(X6),X7) | ? [X10] : s('type.option.option'(X6),X7) = s('type.option.option'(X6),'const.option.SOME_1'(s(X6,X10))))),
  file('thm.option.OPTION_ALL_MONO','thm.option.option_nchotomy')).
fof(f78,plain,(
  ( ! [X2,X0,X1] : (s(bool,happ(s(fun(X0,bool),X1),s(X0,X2))) = s(bool,'const.option.OPTION_ALL_2'(s(fun(X0,bool),X1),s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2)))))) )),
  inference(cnf_transformation,[],[f30])).
fof(f30,plain,(
  ! [X0,X1,X2] : s(bool,happ(s(fun(X0,bool),X1),s(X0,X2))) = s(bool,'const.option.OPTION_ALL_2'(s(fun(X0,bool),X1),s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2)))))),
  inference(flattening,[],[f29])).
fof(f29,plain,(
  ! [X0] : ! [X1,X2] : s(bool,happ(s(fun(X0,bool),X1),s(X0,X2))) = s(bool,'const.option.OPTION_ALL_2'(s(fun(X0,bool),X1),s('type.option.option'(X0),'const.option.SOME_1'(s(X0,X2)))))),
  inference(rectify,[],[f15])).
fof(f15,axiom,(
  ! [X6] : ! [X9,X10] : s(bool,happ(s(fun(X6,bool),X9),s(X6,X10))) = s(bool,'const.option.OPTION_ALL_2'(s(fun(X6,bool),X9),s('type.option.option'(X6),'const.option.SOME_1'(s(X6,X10)))))),
  file('thm.option.OPTION_ALL_MONO','thm.option.OPTION_ALL_def|split|1')).
fof(f90,plain,(
  ( ! [X0] : (~p(s(bool,X0)) | s(bool,'T_0') = s(bool,X0)) ) | $spl7),
  inference(superposition,[],[f85,f60])).
fof(f20289,plain,(
  $false | ($spl11 | $spl14 | $spl492)),
  inference(subsumption_resolution,[],[f20288,f99])).
fof(f20288,plain,(
  s(bool,'T_0') = s(bool,'F_0') | ($spl14 | $spl492)),
  inference(forward_demodulation,[],[f20281,f76])).
fof(f76,plain,(
  ( ! [X0,X1] : (s(bool,'T_0') = s(bool,'const.option.OPTION_ALL_2'(s(fun(X0,bool),X1),s('type.option.option'(X0),'const.option.NONE_0')))) )),
  inference(cnf_transformation,[],[f26])).
fof(f26,plain,(
  ! [X0,X1] : s(bool,'T_0') = s(bool,'const.option.OPTION_ALL_2'(s(fun(X0,bool),X1),s('type.option.option'(X0),'const.option.NONE_0')))),
  inference(flattening,[],[f25])).
fof(f25,plain,(
  ! [X0] : ! [X1] : s(bool,'T_0') = s(bool,'const.option.OPTION_ALL_2'(s(fun(X0,bool),X1),s('type.option.option'(X0),'const.option.NONE_0')))),
  inference(rectify,[],[f14])).
fof(f14,axiom,(
  ! [X6] : ! [X9] : s(bool,'T_0') = s(bool,'const.option.OPTION_ALL_2'(s(fun(X6,bool),X9),s('type.option.option'(X6),'const.option.NONE_0')))),
  file('thm.option.OPTION_ALL_MONO','thm.option.OPTION_ALL_def|split|0')).
fof(f20281,plain,(
  s(bool,'F_0') = s(bool,'const.option.OPTION_ALL_2'(s(fun(sK0,bool),sK2),s('type.option.option'(sK0),'const.option.NONE_0'))) | ($spl14 | $spl492)),
  inference(backward_demodulation,[],[f19998,f351])).
fof(f110,plain,(
  $false | ($spl7 | $spl8)),
  inference(subsumption_resolution,[],[f100,f85])).
fof(f100,plain,(
  p(s(bool,'F_0')) | $spl8),
  inference(backward_demodulation,[],[f97,f55])).
fof(f97,plain,(
  ( ! [X0] : (s(bool,'F_0') = s(bool,X0)) ) | $spl8),
  inference(cnf_transformation,[],[f97_D])).
fof(f97_D,plain,(
  ( ! [X0] : (s(bool,'F_0') = s(bool,X0)) ) <=> ~$spl8),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl8])])).
fof(f99,plain,(
  s(bool,'T_0') != s(bool,'F_0') | $spl11),
  inference(cnf_transformation,[],[f99_D])).
fof(f99_D,plain,(
  s(bool,'T_0') != s(bool,'F_0') <=> ~$spl11),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl11])])).
fof(f95,plain,(
  ( ! [X0] : (s(bool,'T_0') != s(bool,'F_0') | s(bool,'F_0') = s(bool,X0)) )),
  inference(equality_factoring,[],[f60])).
fof(f394,plain,(
  $false | ($spl11 | $spl12)),
  inference(trivial_inequality_removal,[],[f388])).
fof(f388,plain,(
  s(bool,'T_0') != s(bool,'T_0') | ($spl11 | $spl12)),
  inference(superposition,[],[f99,f349])).
fof(f349,plain,(
  ( ! [X9] : (s(bool,'T_0') = s(bool,X9)) ) | $spl12),
  inference(cnf_transformation,[],[f349_D])).
fof(f349_D,plain,(
  ( ! [X9] : (s(bool,'T_0') = s(bool,X9)) ) <=> ~$spl12),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl12])])).
fof(f351,plain,(
  s(bool,'F_0') = s(bool,'const.option.OPTION_ALL_2'(s(fun(sK0,bool),sK2),s('type.option.option'(sK0),sK1))) | $spl14),
  inference(cnf_transformation,[],[f351_D])).
fof(f351_D,plain,(
  s(bool,'F_0') = s(bool,'const.option.OPTION_ALL_2'(s(fun(sK0,bool),sK2),s('type.option.option'(sK0),sK1))) <=> ~$spl14),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl14])])).
fof(f346,plain,(
  ( ! [X9] : (s(bool,'F_0') = s(bool,'const.option.OPTION_ALL_2'(s(fun(sK0,bool),sK2),s('type.option.option'(sK0),sK1))) | s(bool,'T_0') = s(bool,X9)) ) | $spl2),
  inference(duplicate_literal_removal,[],[f306])).
fof(f306,plain,(
  ( ! [X9] : (s(bool,'F_0') = s(bool,'const.option.OPTION_ALL_2'(s(fun(sK0,bool),sK2),s('type.option.option'(sK0),sK1))) | s(bool,'T_0') = s(bool,X9) | s(bool,'T_0') = s(bool,X9)) ) | $spl2),
  inference(superposition,[],[f272,f60])).
fof(f272,plain,(
  ( ! [X9] : (s(bool,X9) = s(bool,'const.option.OPTION_ALL_2'(s(fun(sK0,bool),sK2),s('type.option.option'(sK0),sK1))) | s(bool,'T_0') = s(bool,X9)) ) | $spl2),
  inference(subsumption_resolution,[],[f194,f82])).
fof(f194,plain,(
  ( ! [X9] : (~p(s(bool,'T_0')) | s(bool,X9) = s(bool,'const.option.OPTION_ALL_2'(s(fun(sK0,bool),sK2),s('type.option.option'(sK0),sK1))) | s(bool,'T_0') = s(bool,X9)) )),
  inference(superposition,[],[f56,f88])).
fof(f88,plain,(
  ( ! [X0,X1] : (s(bool,X0) = s(bool,X1) | s(bool,'T_0') = s(bool,X1) | s(bool,'T_0') = s(bool,X0)) )),
  inference(superposition,[],[f60,f60])).
fof(f56,plain,(
  ~p(s(bool,'const.option.OPTION_ALL_2'(s(fun(sK0,bool),sK2),s('type.option.option'(sK0),sK1))))),
  inference(cnf_transformation,[],[f41])).
fof(f85,plain,(
  ~p(s(bool,'F_0')) | $spl7),
  inference(cnf_transformation,[],[f85_D])).
fof(f85_D,plain,(
  ~p(s(bool,'F_0')) <=> ~$spl7),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl7])])).
fof(f59,plain,(
  ~p(s(bool,'F_0'))),
  inference(cnf_transformation,[],[f18])).
fof(f18,plain,(
  ~p(s(bool,'F_0'))),
  inference(flattening,[],[f2])).
fof(f2,axiom,(
  ~p(s(bool,'F_0'))),
  file('thm.option.OPTION_ALL_MONO',aHL_FALSITY)).
fof(f82,plain,(
  p(s(bool,'T_0')) | $spl2),
  inference(cnf_transformation,[],[f82_D])).
fof(f82_D,plain,(
  p(s(bool,'T_0')) <=> ~$spl2),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl2])])).
fof(f57,plain,(
  p(s(bool,'T_0'))),
  inference(cnf_transformation,[],[f7])).
fof(f7,axiom,(
  p(s(bool,'T_0'))),
  file('thm.option.OPTION_ALL_MONO','thm.bool.TRUTH')).
fof(f20246,plain,(
  s('type.option.option'(sK0),'const.option.NONE_0') = s('type.option.option'(sK0),sK1) | ($spl2 | $spl7 | $spl14 | $spl494)),
  inference(subsumption_resolution,[],[f20245,f85])).
fof(f20245,plain,(
  p(s(bool,'F_0')) | s('type.option.option'(sK0),'const.option.NONE_0') = s('type.option.option'(sK0),sK1) | ($spl2 | $spl14 | $spl494)),
  inference(forward_demodulation,[],[f20209,f351])).
fof(f20209,plain,(
  p(s(bool,'const.option.OPTION_ALL_2'(s(fun(sK0,bool),sK2),s('type.option.option'(sK0),sK1)))) | s('type.option.option'(sK0),'const.option.NONE_0') = s('type.option.option'(sK0),sK1) | ($spl2 | $spl494)),
  inference(superposition,[],[f20182,f472])).
fof(f20182,plain,(
  p(s(bool,happ(s(fun(sK0,bool),sK2),s(sK0,sK4(sK1,sK0))))) | ($spl2 | $spl494)),
  inference(subsumption_resolution,[],[f20071,f82])).
fof(f20071,plain,(
  ~p(s(bool,'T_0')) | p(s(bool,happ(s(fun(sK0,bool),sK2),s(sK0,sK4(sK1,sK0))))) | $spl494),
  inference(superposition,[],[f54,f20000])).
fof(f54,plain,(
  ( ! [X4] : (~p(s(bool,happ(s(fun(sK0,bool),sK3),s(sK0,X4)))) | p(s(bool,happ(s(fun(sK0,bool),sK2),s(sK0,X4))))) )),
  inference(cnf_transformation,[],[f41])).
% SZS output end Proof for thm.option
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Refutation

% Active clauses: 134
% Passive clauses: 1582
% Generated clauses: 19867
% Final active clauses: 114
% Final passive clauses: 1315
% Input formulas: 14
% Initial clauses: 26
% 
% Duplicate literals: 1110
% Trivial inequalities: 217
% Fw subsumption resolutions: 2161
% Fw demodulations: 2332
% Bw demodulations: 16
% 
% Simple tautologies: 299
% Equational tautologies: 67
% Forward subsumptions: 10711
% 
% Binary resolution: 59
% Forward superposition: 7533
% Backward superposition: 5705
% Self superposition: 300
% Equality factoring: 183
% Equality resolution: 20
% 
% Split clauses: 983
% Split components: 1994
% SAT solver clauses: 1526
% SAT solver unit clauses: 21
% SAT solver binary clauses: 114
% SAT solver learnt clauses: 1
% 
% Sat splits: 983
% Sat splitting refutations: 8
% 
% TWLsolver clauses: 1515
% TWLsolver calls for satisfiability: 97
% 
% Memory used [KB]: 9594
% Time elapsed: 0.451 s
% ------------------------------
% ------------------------------
% Success in time 0.453 s
