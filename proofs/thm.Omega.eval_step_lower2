Hi Geoff, go and have some cold beer while I am trying to solve this very hard problem!
% remaining time: 149 next slice time: 5
dis+11_7_3 on thm.Omega
% (102010)Time limit reached!
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Time limit
% Termination phase: Saturation

% Active clauses: 203
% Passive clauses: 3073
% Generated clauses: 22299
% Final active clauses: 158
% Final passive clauses: 2529
% Input formulas: 69
% Initial clauses: 116
% 
% Duplicate literals: 624
% Trivial inequalities: 225
% Fw subsumption resolutions: 1496
% Fw demodulations: 2991
% Bw demodulations: 42
% 
% Simple tautologies: 316
% Equational tautologies: 24
% Forward subsumptions: 13428
% 
% Binary resolution: 101
% Forward superposition: 9506
% Backward superposition: 6753
% Self superposition: 268
% Equality factoring: 53
% Equality resolution: 37
% 
% Split clauses: 202
% Split components: 420
% SAT solver clauses: 398
% SAT solver unit clauses: 12
% SAT solver binary clauses: 61
% 
% Sat splits: 202
% Sat splitting refutations: 4
% 
% TWLsolver clauses: 396
% TWLsolver calls for satisfiability: 65
% 
% Memory used [KB]: 20212
% Time elapsed: 0.600 s
% ------------------------------
% ------------------------------
% remaining time: 143 next slice time: 6
lrs-11_2_cond=on:fde=unused:gs=on:nwc=3:stl=30:sdd=off:sfr=on:ssfp=100000:ssfq=1.4:smm=sco:ssnc=all_4 on thm.Omega
% (102028)Time limit reached!
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Time limit
% Termination phase: Saturation

% Active clauses: 201
% Passive clauses: 1299
% Generated clauses: 25794
% Final active clauses: 84
% Final passive clauses: 360
% Input formulas: 69
% Initial clauses: 116
% 
% Duplicate literals: 548
% Trivial inequalities: 382
% Fw subsumption resolutions: 2046
% Fw demodulations: 4443
% Bw demodulations: 783
% Condensations: 1303
% Global subsumptions: 17
% 
% Simple tautologies: 387
% Equational tautologies: 23
% Forward subsumptions: 12566
% Fw demodulations to eq. taut.: 32
% Bw demodulations to eq. taut.: 15
% 
% Binary resolution: 54
% Forward superposition: 7208
% Backward superposition: 4967
% Self superposition: 192
% Equality factoring: 49
% Equality resolution: 42
% 
% Split clauses: 179
% Split components: 368
% SAT solver clauses: 2355
% SAT solver unit clauses: 193
% SAT solver binary clauses: 85
% SAT solver learnt clauses: 39
% SAT solver learnt literals: 14
% 
% Sat splits: 179
% Sat splitting refutations: 210
% 
% TWLsolver clauses: 2282
% TWLsolver calls for satisfiability: 580
% 
% Memory used [KB]: 16886
% Time elapsed: 0.700 s
% ------------------------------
% ------------------------------
% remaining time: 136 next slice time: 103
lrs+11_2_br=off:cond=on:fde=none:gs=on:gsaa=full_model:lwlo=on:nwc=2:sas=minisat:stl=30:ssfp=100000:ssfq=1.4:smm=sco:ssnc=none:sp=occurrence:urr=on_98 on thm.Omega
% (102043)Time limit reached!
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Time limit
% Termination phase: Saturation

% Active clauses: 673
% Passive clauses: 9069
% Generated clauses: 237450
% Final active clauses: 147
% Final passive clauses: 216
% Input formulas: 69
% Initial clauses: 116
% Discarded non-redundant clauses: 14305
% 
% Duplicate literals: 3684
% Trivial inequalities: 1356
% Fw subsumption resolutions: 22131
% Fw demodulations: 65200
% Bw demodulations: 3677
% Condensations: 13243
% Global subsumptions: 79
% 
% Simple tautologies: 1728
% Equational tautologies: 695
% Forward subsumptions: 117799
% Fw demodulations to eq. taut.: 943
% Bw demodulations to eq. taut.: 424
% 
% Unit resulting resolution: 13919
% Forward superposition: 62381
% Backward superposition: 40232
% Self superposition: 514
% Equality factoring: 112
% Equality resolution: 152
% 
% Split clauses: 237
% Split components: 496
% SAT solver clauses: 10093
% SAT solver unit clauses: 1060
% SAT solver binary clauses: 1593
% 
% Sat splits: 237
% Sat splitting refutations: 468
% 
% Memory used [KB]: 115136
% Time elapsed: 10.400 s
% ------------------------------
% ------------------------------
% remaining time: 32 next slice time: 32
dis+11_5_fde=none:nwc=1:sas=minisat:sd=1:ss=axioms:st=5.0:sos=all:sdd=large:sser=off:sfr=on:ssfp=100000:ssfq=2.0:ssnc=none_37 on thm.Omega
% Refutation found. Thanks to Tanya!
% SZS status Theorem for thm.Omega
% SZS output start Proof for thm.Omega
fof(f560,plain,(
  $false),
  inference(sat_splitting_refutation,[],[f204,f212,f210,f208,f206,f143,f142,f141,f140,f139,f138,f136,f135,f134,f133,f132,f131,f130,f207,f129,f211,f128,f214,f127,f209,f126,f205,f216,f322,f342,f323,f343,f324,f344,f363,f359,f353,f352,f387,f388,f406,f408,f409,f464,f482,f501,f518,f538,f522,f341,f539,f481,f541])).
fof(f541,plain,(
  $false | $spl20),
  inference(resolution,[],[f481,f199])).
fof(f199,plain,(
  p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1))))),
  inference(duplicate_literal_removal,[],[f125])).
fof(f125,plain,(
  p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1)))) | p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1))))),
  inference(cnf_transformation,[],[f107])).
fof(f107,plain,(
  ((p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))) & p(s(bool,sK5)) & p(s(bool,'const.integer.int_le_2'(s('type.integer.int',sK2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',sK6))),s('type.integer.int',sK0)))))) & p(s(bool,sK3))) | (p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) & p(s(bool,sK5)) & p(s(bool,sK3)))) & (~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1)))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))) | ~p(s(bool,sK5)) | ~p(s(bool,'const.integer.int_le_2'(s('type.integer.int',sK2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',sK6))),s('type.integer.int',sK0)))))) | ~p(s(bool,sK3)) | ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1)))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) | ~p(s(bool,sK5)) | ~p(s(bool,sK3)))),
  inference(skolemisation,[status(esa),new_symbols(skolem,[sK0,sK1,sK2,sK3,sK4,sK5,sK6])],[f106])).
fof(f106,plain,(
  ? [X0,X1,X2,X3,X4,X5,X6] : (((p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4)))) & p(s(bool,X5)) & p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X6))),s('type.integer.int',X0)))))) & p(s(bool,X3))) | (p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X6),s('type.integer.int',X2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4)))))) & p(s(bool,X5)) & p(s(bool,X3)))) & (~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4)))) | ~p(s(bool,X5)) | ~p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X6))),s('type.integer.int',X0)))))) | ~p(s(bool,X3)) | ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X6),s('type.integer.int',X2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4)))))) | ~p(s(bool,X5)) | ~p(s(bool,X3))))),
  inference(flattening,[],[f105])).
fof(f105,plain,(
  ? [X0,X1,X2,X3,X4,X5,X6] : (((p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4)))) & p(s(bool,X5)) & p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X6))),s('type.integer.int',X0)))))) & p(s(bool,X3))) | (p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X6),s('type.integer.int',X2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4)))))) & p(s(bool,X5)) & p(s(bool,X3)))) & ((~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4)))) | ~p(s(bool,X5)) | ~p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X6))),s('type.integer.int',X0)))))) | ~p(s(bool,X3))) | (~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X6),s('type.integer.int',X2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4)))))) | ~p(s(bool,X5)) | ~p(s(bool,X3)))))),
  inference(nnf_transformation,[],[f103])).
fof(f103,plain,(
  ? [X0,X1,X2,X3,X4,X5,X6] : ((p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4)))) & p(s(bool,X5)) & p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X6))),s('type.integer.int',X0)))))) & p(s(bool,X3))) <~> (p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X6),s('type.integer.int',X2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4)))))) & p(s(bool,X5)) & p(s(bool,X3))))),
  inference(ennf_transformation,[],[f71])).
fof(f71,plain,(
  ~! [X0,X1,X2,X3,X4,X5,X6] : ((p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4)))) & p(s(bool,X5)) & p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X6))),s('type.integer.int',X0)))))) & p(s(bool,X3))) <=> (p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X6),s('type.integer.int',X2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4)))))) & p(s(bool,X5)) & p(s(bool,X3))))),
  inference(rectify,[],[f6])).
fof(f6,negated_conjecture,(
  ~! [X6,X7,X8,X9,X10,X11,X12] : ((p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X6),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X7)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X6),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X10)))) & p(s(bool,X11)) & p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X8),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X12))),s('type.integer.int',X6)))))) & p(s(bool,X9))) <=> (p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X6),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X7)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X6),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X12),s('type.integer.int',X8))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X10)))))) & p(s(bool,X11)) & p(s(bool,X9))))),
  inference(negated_conjecture,[],[f5])).
fof(f5,conjecture,(
  ! [X6,X7,X8,X9,X10,X11,X12] : ((p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X6),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X7)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X6),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X10)))) & p(s(bool,X11)) & p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X8),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X12))),s('type.integer.int',X6)))))) & p(s(bool,X9))) <=> (p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X6),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X7)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X6),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X12),s('type.integer.int',X8))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X10)))))) & p(s(bool,X11)) & p(s(bool,X9))))),
  file('thm.Omega.eval_step_lower2','thm.Omega.eval_step_lower2')).
fof(f481,plain,(
  ( ! [X3] : (~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3))))) ) | $spl20),
  inference(cnf_transformation,[],[f481_D])).
fof(f481_D,plain,(
  ( ! [X3] : (~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3))))) ) <=> ~$spl20),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl20])])).
fof(f539,plain,(
  ( ! [X4,X3] : (~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X3),s('type.integer.int',X4))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4))))))))) ) | $spl26),
  inference(cnf_transformation,[],[f539_D])).
fof(f539_D,plain,(
  ( ! [X4,X3] : (~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X3),s('type.integer.int',X4))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4))))))))) ) <=> ~$spl26),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl26])])).
fof(f341,plain,(
  ( ! [X3] : (~p(s(bool,X3))) ) | $spl12),
  inference(cnf_transformation,[],[f341_D])).
fof(f341_D,plain,(
  ( ! [X3] : (~p(s(bool,X3))) ) <=> ~$spl12),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl12])])).
fof(f522,plain,(
  ( ! [X4,X2,X5,X3] : (~p(s(bool,X2)) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X3),s('type.integer.int',X4))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))))) | ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X5))))) ) | $spl3),
  inference(resolution,[],[f208,f150])).
fof(f150,plain,(
  ( ! [X4,X2,X0,X5,X3,X1] : (p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3)))) | ~p(s(bool,X4)) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X5),s('type.integer.int',X2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3)))))) | ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1))))) )),
  inference(cnf_transformation,[],[f109])).
fof(f109,plain,(
  ! [X0,X1,X2,X3,X4,X5] : ((~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3)))) | ~p(s(bool,X4)) | ~p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X5))),s('type.integer.int',X0)))))) | (p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X5),s('type.integer.int',X2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3)))))) & p(s(bool,X4)))) & (~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X5),s('type.integer.int',X2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3)))))) | ~p(s(bool,X4)) | (p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3)))) & p(s(bool,X4)) & p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X5))),s('type.integer.int',X0)))))))))),
  inference(flattening,[],[f108])).
fof(f108,plain,(
  ! [X0,X1,X2,X3,X4,X5] : (((~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3)))) | ~p(s(bool,X4)) | ~p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X5))),s('type.integer.int',X0))))))) | (p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X5),s('type.integer.int',X2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3)))))) & p(s(bool,X4)))) & ((~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X5),s('type.integer.int',X2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3)))))) | ~p(s(bool,X4))) | (p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3)))) & p(s(bool,X4)) & p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X5))),s('type.integer.int',X0)))))))))),
  inference(nnf_transformation,[],[f72])).
fof(f72,plain,(
  ! [X0,X1,X2,X3,X4,X5] : ((p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3)))) & p(s(bool,X4)) & p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X5))),s('type.integer.int',X0))))))) <=> (p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X5),s('type.integer.int',X2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3)))))) & p(s(bool,X4))))),
  inference(rectify,[],[f7])).
fof(f7,axiom,(
  ! [X6,X7,X8,X10,X11,X12] : ((p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X6),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X7)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X6),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X10)))) & p(s(bool,X11)) & p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X8),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X12))),s('type.integer.int',X6))))))) <=> (p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X6),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X7)))) & p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X6),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X12),s('type.integer.int',X8))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X10)))))) & p(s(bool,X11))))),
  file('thm.Omega.eval_step_lower2','thm.Omega.eval_step_lower|49|')).
fof(f538,plain,(
  ( ! [X0,X1] : (~p(s(bool,X0)) | ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1))))) ) | ($spl3 | $spl8 | $spl10)),
  inference(subsumption_resolution,[],[f537,f216])).
fof(f537,plain,(
  ( ! [X0,X1] : (~p(s(bool,X0)) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))) | ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1))))) ) | ($spl3 | $spl8)),
  inference(subsumption_resolution,[],[f521,f214])).
fof(f521,plain,(
  ( ! [X0,X1] : (~p(s(bool,'const.integer.int_le_2'(s('type.integer.int',sK2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',sK6))),s('type.integer.int',sK0)))))) | ~p(s(bool,X0)) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))) | ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1))))) ) | $spl3),
  inference(resolution,[],[f208,f147])).
fof(f147,plain,(
  ( ! [X4,X2,X0,X5,X3,X1] : (p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X5),s('type.integer.int',X2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3)))))) | ~p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X5))),s('type.integer.int',X0)))))) | ~p(s(bool,X4)) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3)))) | ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1))))) )),
  inference(cnf_transformation,[],[f109])).
fof(f518,plain,(
  ( ! [X0] : (p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X0)))))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X0))))) ) | $spl24),
  inference(cnf_transformation,[],[f518_D])).
fof(f518_D,plain,(
  ( ! [X0] : (p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X0)))))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X0))))) ) <=> ~$spl24),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl24])])).
fof(f501,plain,(
  ( ! [X2,X0,X1] : (p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X0)))))) | ~p(s(bool,X1)) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X0)))) | ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X2))))) ) | $spl8),
  inference(resolution,[],[f214,f147])).
fof(f482,plain,(
  ( ! [X0,X1] : (p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X0),s('type.integer.int',X1))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) | ~p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X1),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X0))),s('type.integer.int',sK0))))))) ) | $spl22),
  inference(cnf_transformation,[],[f482_D])).
fof(f482_D,plain,(
  ( ! [X0,X1] : (p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X0),s('type.integer.int',X1))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) | ~p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X1),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X0))),s('type.integer.int',sK0))))))) ) <=> ~$spl22),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl22])])).
fof(f464,plain,(
  ( ! [X2,X0,X3,X1] : (p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X0),s('type.integer.int',X1))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) | ~p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X1),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X0))),s('type.integer.int',sK0)))))) | ~p(s(bool,X2)) | ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3))))) ) | $spl10),
  inference(resolution,[],[f216,f147])).
fof(f409,plain,(
  $false | $spl7),
  inference(subsumption_resolution,[],[f212,f201])).
fof(f201,plain,(
  p(s(bool,sK3))),
  inference(duplicate_literal_removal,[],[f144])).
fof(f144,plain,(
  p(s(bool,sK3)) | p(s(bool,sK3))),
  inference(cnf_transformation,[],[f107])).
fof(f408,plain,(
  $false | $spl5),
  inference(subsumption_resolution,[],[f407,f184])).
fof(f184,plain,(
  p(s(bool,'T_0'))),
  inference(cnf_transformation,[],[f1])).
fof(f1,axiom,(
  p(s(bool,'T_0'))),
  file('thm.Omega.eval_step_lower2',aHL_TRUTH)).
fof(f407,plain,(
  ~p(s(bool,'T_0')) | $spl5),
  inference(forward_demodulation,[],[f210,f223])).
fof(f223,plain,(
  s(bool,'T_0') = s(bool,sK5)),
  inference(resolution,[],[f200,f175])).
fof(f175,plain,(
  ( ! [X0] : (s(bool,'T_0') = s(bool,X0) | ~p(s(bool,X0))) )),
  inference(cnf_transformation,[],[f120])).
fof(f120,plain,(
  ! [X0] : ((s(bool,'T_0') != s(bool,X0) | p(s(bool,X0))) & (~p(s(bool,X0)) | s(bool,'T_0') = s(bool,X0)))),
  inference(nnf_transformation,[],[f85])).
fof(f85,plain,(
  ! [X0] : (s(bool,'T_0') = s(bool,X0) <=> p(s(bool,X0)))),
  inference(rectify,[],[f61])).
fof(f61,axiom,(
  ! [X28] : (s(bool,'T_0') = s(bool,X28) <=> p(s(bool,X28)))),
  file('thm.Omega.eval_step_lower2','thm.bool.EQ_CLAUSES|split|1')).
fof(f200,plain,(
  p(s(bool,sK5))),
  inference(duplicate_literal_removal,[],[f137])).
fof(f137,plain,(
  p(s(bool,sK5)) | p(s(bool,sK5))),
  inference(cnf_transformation,[],[f107])).
fof(f406,plain,(
  $false | $spl1),
  inference(subsumption_resolution,[],[f206,f199])).
fof(f388,plain,(
  $false | $spl12),
  inference(subsumption_resolution,[],[f355,f178])).
fof(f178,plain,(
  ~p(s(bool,'F_0'))),
  inference(cnf_transformation,[],[f87])).
fof(f87,plain,(
  ~p(s(bool,'F_0'))),
  inference(flattening,[],[f2])).
fof(f2,axiom,(
  ~p(s(bool,'F_0'))),
  file('thm.Omega.eval_step_lower2',aHL_FALSITY)).
fof(f355,plain,(
  p(s(bool,'F_0')) | $spl12),
  inference(resolution,[],[f341,f179])).
fof(f179,plain,(
  p(s(bool,'F_0')) | p(s(bool,'T_0'))),
  inference(cnf_transformation,[],[f122])).
fof(f122,plain,(
  (p(s(bool,'T_0')) | p(s(bool,'F_0'))) & (~p(s(bool,'F_0')) | ~p(s(bool,'T_0')))),
  inference(nnf_transformation,[],[f88])).
fof(f88,plain,(
  ~p(s(bool,'T_0')) <=> p(s(bool,'F_0'))),
  inference(flattening,[],[f65])).
fof(f65,axiom,(
  ~p(s(bool,'T_0')) <=> p(s(bool,'F_0'))),
  file('thm.Omega.eval_step_lower2','thm.bool.NOT_CLAUSES|split|1')).
fof(f387,plain,(
  $false | $spl12),
  inference(subsumption_resolution,[],[f354,f178])).
fof(f354,plain,(
  p(s(bool,'F_0')) | $spl12),
  inference(resolution,[],[f341,f181])).
fof(f181,plain,(
  p(s(bool,'T_0')) | p(s(bool,'F_0'))),
  inference(cnf_transformation,[],[f123])).
fof(f123,plain,(
  (p(s(bool,'F_0')) | p(s(bool,'T_0'))) & (~p(s(bool,'T_0')) | ~p(s(bool,'F_0')))),
  inference(nnf_transformation,[],[f89])).
fof(f89,plain,(
  ~p(s(bool,'F_0')) <=> p(s(bool,'T_0'))),
  inference(flattening,[],[f70])).
fof(f70,axiom,(
  ~p(s(bool,'F_0')) <=> p(s(bool,'T_0'))),
  file('thm.Omega.eval_step_lower2','thm.bool.NOT_CLAUSES|split|2')).
fof(f352,plain,(
  $false | $spl12),
  inference(resolution,[],[f341,f184])).
fof(f353,plain,(
  $false | $spl12),
  inference(resolution,[],[f341,f183])).
fof(f183,plain,(
  p(s(bool,'T_0'))),
  inference(cnf_transformation,[],[f40])).
fof(f40,axiom,(
  p(s(bool,'T_0'))),
  file('thm.Omega.eval_step_lower2','thm.bool.TRUTH')).
fof(f359,plain,(
  $false | $spl12),
  inference(resolution,[],[f341,f199])).
fof(f363,plain,(
  $false | $spl12),
  inference(resolution,[],[f341,f201])).
fof(f344,plain,(
  ( ! [X8,X11,X9] : (p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X8),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X9))),s('type.integer.int',sK0)))))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X9),s('type.integer.int',X8))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X11))))))) ) | $spl18),
  inference(cnf_transformation,[],[f344_D])).
fof(f344_D,plain,(
  ( ! [X8,X11,X9] : (p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X8),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X9))),s('type.integer.int',sK0)))))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X9),s('type.integer.int',X8))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X11))))))) ) <=> ~$spl18),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl18])])).
fof(f324,plain,(
  ( ! [X10,X8,X11,X9] : (p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X8),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X9))),s('type.integer.int',sK0)))))) | ~p(s(bool,X10)) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X9),s('type.integer.int',X8))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X11))))))) )),
  inference(resolution,[],[f199,f152])).
fof(f152,plain,(
  ( ! [X4,X2,X0,X5,X3,X1] : (p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X5))),s('type.integer.int',X0)))))) | ~p(s(bool,X4)) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X5),s('type.integer.int',X2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X3)))))) | ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',X0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X1))))) )),
  inference(cnf_transformation,[],[f109])).
fof(f343,plain,(
  ( ! [X6,X4,X7] : (p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4)))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X6),s('type.integer.int',X7))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4))))))) ) | $spl16),
  inference(cnf_transformation,[],[f343_D])).
fof(f343_D,plain,(
  ( ! [X6,X4,X7] : (p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4)))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X6),s('type.integer.int',X7))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4))))))) ) <=> ~$spl16),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl16])])).
fof(f323,plain,(
  ( ! [X6,X4,X7,X5] : (p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4)))) | ~p(s(bool,X5)) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X6),s('type.integer.int',X7))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X4))))))) )),
  inference(resolution,[],[f199,f150])).
fof(f342,plain,(
  ( ! [X2,X0,X1] : (p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X0),s('type.integer.int',X1))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X2)))))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X2)))) | ~p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X1),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X0))),s('type.integer.int',sK0))))))) ) | $spl14),
  inference(cnf_transformation,[],[f342_D])).
fof(f342_D,plain,(
  ( ! [X2,X0,X1] : (p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X0),s('type.integer.int',X1))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X2)))))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X2)))) | ~p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X1),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X0))),s('type.integer.int',sK0))))))) ) <=> ~$spl14),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl14])])).
fof(f322,plain,(
  ( ! [X2,X0,X3,X1] : (p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',X0),s('type.integer.int',X1))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X2)))))) | ~p(s(bool,'const.integer.int_le_2'(s('type.integer.int',X1),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',X0))),s('type.integer.int',sK0)))))) | ~p(s(bool,X3)) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),X2))))) )),
  inference(resolution,[],[f199,f147])).
fof(f216,plain,(
  p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))) | $spl10),
  inference(cnf_transformation,[],[f216_D])).
fof(f216_D,plain,(
  p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))) <=> ~$spl10),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl10])])).
fof(f205,plain,(
  p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1)))) | $spl0),
  inference(cnf_transformation,[],[f205_D])).
fof(f205_D,plain,(
  p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1)))) <=> ~$spl0),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl0])])).
fof(f126,plain,(
  p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1)))) | p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4))))),
  inference(cnf_transformation,[],[f107])).
fof(f209,plain,(
  p(s(bool,sK5)) | $spl4),
  inference(cnf_transformation,[],[f209_D])).
fof(f209_D,plain,(
  p(s(bool,sK5)) <=> ~$spl4),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl4])])).
fof(f127,plain,(
  p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1)))) | p(s(bool,sK5))),
  inference(cnf_transformation,[],[f107])).
fof(f214,plain,(
  p(s(bool,'const.integer.int_le_2'(s('type.integer.int',sK2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',sK6))),s('type.integer.int',sK0)))))) | $spl8),
  inference(cnf_transformation,[],[f214_D])).
fof(f214_D,plain,(
  p(s(bool,'const.integer.int_le_2'(s('type.integer.int',sK2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',sK6))),s('type.integer.int',sK0)))))) <=> ~$spl8),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl8])])).
fof(f128,plain,(
  p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1)))) | p(s(bool,'const.integer.int_le_2'(s('type.integer.int',sK2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',sK6))),s('type.integer.int',sK0))))))),
  inference(cnf_transformation,[],[f107])).
fof(f211,plain,(
  p(s(bool,sK3)) | $spl6),
  inference(cnf_transformation,[],[f211_D])).
fof(f211_D,plain,(
  p(s(bool,sK3)) <=> ~$spl6),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl6])])).
fof(f129,plain,(
  p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1)))) | p(s(bool,sK3))),
  inference(cnf_transformation,[],[f107])).
fof(f207,plain,(
  p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) | $spl2),
  inference(cnf_transformation,[],[f207_D])).
fof(f207_D,plain,(
  p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) <=> ~$spl2),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl2])])).
fof(f130,plain,(
  p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) | p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1))))),
  inference(cnf_transformation,[],[f107])).
fof(f131,plain,(
  p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) | p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4))))),
  inference(cnf_transformation,[],[f107])).
fof(f132,plain,(
  p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) | p(s(bool,sK5))),
  inference(cnf_transformation,[],[f107])).
fof(f133,plain,(
  p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) | p(s(bool,'const.integer.int_le_2'(s('type.integer.int',sK2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',sK6))),s('type.integer.int',sK0))))))),
  inference(cnf_transformation,[],[f107])).
fof(f134,plain,(
  p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) | p(s(bool,sK3))),
  inference(cnf_transformation,[],[f107])).
fof(f135,plain,(
  p(s(bool,sK5)) | p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1))))),
  inference(cnf_transformation,[],[f107])).
fof(f136,plain,(
  p(s(bool,sK5)) | p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4))))),
  inference(cnf_transformation,[],[f107])).
fof(f138,plain,(
  p(s(bool,sK5)) | p(s(bool,'const.integer.int_le_2'(s('type.integer.int',sK2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',sK6))),s('type.integer.int',sK0))))))),
  inference(cnf_transformation,[],[f107])).
fof(f139,plain,(
  p(s(bool,sK5)) | p(s(bool,sK3))),
  inference(cnf_transformation,[],[f107])).
fof(f140,plain,(
  p(s(bool,sK3)) | p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1))))),
  inference(cnf_transformation,[],[f107])).
fof(f141,plain,(
  p(s(bool,sK3)) | p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4))))),
  inference(cnf_transformation,[],[f107])).
fof(f142,plain,(
  p(s(bool,sK3)) | p(s(bool,sK5))),
  inference(cnf_transformation,[],[f107])).
fof(f143,plain,(
  p(s(bool,sK3)) | p(s(bool,'const.integer.int_le_2'(s('type.integer.int',sK2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',sK6))),s('type.integer.int',sK0))))))),
  inference(cnf_transformation,[],[f107])).
fof(f206,plain,(
  ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1)))) | $spl1),
  inference(cnf_transformation,[],[f206_D])).
fof(f206_D,plain,(
  ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1)))) <=> ~$spl1),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl1])])).
fof(f208,plain,(
  ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) | $spl3),
  inference(cnf_transformation,[],[f208_D])).
fof(f208_D,plain,(
  ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) <=> ~$spl3),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl3])])).
fof(f210,plain,(
  ~p(s(bool,sK5)) | $spl5),
  inference(cnf_transformation,[],[f210_D])).
fof(f210_D,plain,(
  ~p(s(bool,sK5)) <=> ~$spl5),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl5])])).
fof(f212,plain,(
  ~p(s(bool,sK3)) | $spl7),
  inference(cnf_transformation,[],[f212_D])).
fof(f212_D,plain,(
  ~p(s(bool,sK3)) <=> ~$spl7),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl7])])).
fof(f204,plain,(
  ~p(s(bool,sK3)) | ~p(s(bool,sK5)) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) | ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1))))),
  inference(subsumption_resolution,[],[f203,f152])).
fof(f203,plain,(
  ~p(s(bool,sK3)) | ~p(s(bool,sK5)) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) | ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1)))) | ~p(s(bool,'const.integer.int_le_2'(s('type.integer.int',sK2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',sK6))),s('type.integer.int',sK0))))))),
  inference(subsumption_resolution,[],[f202,f150])).
fof(f202,plain,(
  ~p(s(bool,sK3)) | ~p(s(bool,sK5)) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) | ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1)))) | ~p(s(bool,'const.integer.int_le_2'(s('type.integer.int',sK2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',sK6))),s('type.integer.int',sK0)))))) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4))))),
  inference(duplicate_literal_removal,[],[f145])).
fof(f145,plain,(
  ~p(s(bool,sK3)) | ~p(s(bool,sK5)) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),'const.list.CONS_2'(s('type.pair.prod'('type.num.num','type.integer.int'),'const.pair.,_2'(s('type.num.num',sK6),s('type.integer.int',sK2))),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))))) | ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1)))) | ~p(s(bool,sK3)) | ~p(s(bool,'const.integer.int_le_2'(s('type.integer.int',sK2),s('type.integer.int','const.integer.int_mul_2'(s('type.integer.int','const.integer.int_of_num_1'(s('type.num.num',sK6))),s('type.integer.int',sK0)))))) | ~p(s(bool,sK5)) | ~p(s(bool,'const.Omega.evallower_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK4)))) | ~p(s(bool,'const.Omega.evalupper_2'(s('type.integer.int',sK0),s('type.list.list'('type.pair.prod'('type.num.num','type.integer.int')),sK1))))),
  inference(cnf_transformation,[],[f107])).
% SZS output end Proof for thm.Omega
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Refutation

% Active clauses: 48
% Passive clauses: 85
% Generated clauses: 377
% Final active clauses: 43
% Final passive clauses: 46
% Input formulas: 69
% Initial clauses: 74
% 
% Selected by SInE selection: 30
% SInE iterations: 1
% 
% Duplicate literals: 11
% Trivial inequalities: 16
% Fw subsumption resolutions: 36
% Fw demodulations: 29
% Bw demodulations: 4
% 
% Simple tautologies: 28
% Forward subsumptions: 171
% 
% Binary resolution: 75
% Forward superposition: 117
% Backward superposition: 54
% 
% Split clauses: 25
% Split components: 55
% SAT solver clauses: 36
% SAT solver unit clauses: 10
% SAT solver binary clauses: 20
% 
% Sat splits: 25
% Sat splitting refutations: 10
% 
% Memory used [KB]: 1151
% Time elapsed: 0.008 s
% ------------------------------
% ------------------------------
% Success in time 11.744 s
