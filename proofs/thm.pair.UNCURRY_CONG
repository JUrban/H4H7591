Hi Geoff, go and have some cold beer while I am trying to solve this very hard problem!
% remaining time: 300 next slice time: 5
dis+11_7_3 on thm.pair
% (62510)Time limit reached!
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Time limit
% Termination phase: Saturation

% Active clauses: 159
% Passive clauses: 3035
% Generated clauses: 17961
% Final active clauses: 152
% Final passive clauses: 2741
% Input formulas: 22
% Initial clauses: 57
% 
% Duplicate literals: 803
% Trivial inequalities: 279
% Fw subsumption resolutions: 2013
% Fw demodulations: 2205
% Bw demodulations: 3
% 
% Simple tautologies: 365
% Equational tautologies: 30
% Forward subsumptions: 8052
% Fw demodulations to eq. taut.: 5
% 
% Binary resolution: 301
% Forward superposition: 6966
% Backward superposition: 4885
% Self superposition: 140
% Equality factoring: 64
% Equality resolution: 50
% 
% Split clauses: 797
% Split components: 1611
% SAT solver clauses: 1308
% SAT solver unit clauses: 56
% SAT solver binary clauses: 414
% 
% Sat splits: 797
% Sat splitting refutations: 2
% 
% TWLsolver clauses: 1307
% TWLsolver calls for satisfiability: 162
% 
% Memory used [KB]: 13560
% Time elapsed: 0.600 s
% ------------------------------
% ------------------------------
% remaining time: 293 next slice time: 6
lrs-11_2_cond=on:fde=unused:gs=on:nwc=3:stl=30:sdd=off:sfr=on:ssfp=100000:ssfq=1.4:smm=sco:ssnc=all_4 on thm.pair
% Refutation found. Thanks to Tanya!
% SZS status Theorem for thm.pair
% SZS output start Proof for thm.pair
fof(f2133,plain,(
  $false),
  inference(sat_splitting_refutation,[],[f2125,f88,f162,f183,f185,f90,f159,f2114,f2115,f572,f579,f89,f160,f118,f175,f1993,f2068,f136,f181])).
fof(f181,plain,(
  ( ! [X4,X2,X0,X5,X3,X1] : (s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X3),s(X1,X4))),s(X2,X5))) = s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),'const.pair.,_2'(s(X1,X4),s(X2,X5)))))) ) | $spl38),
  inference(cnf_transformation,[],[f181_D])).
fof(f181_D,plain,(
  ( ! [X4,X2,X0,X5,X3,X1] : (s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X3),s(X1,X4))),s(X2,X5))) = s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),'const.pair.,_2'(s(X1,X4),s(X2,X5)))))) ) <=> ~$spl38),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl38])])).
fof(f136,plain,(
  ( ! [X4,X2,X0,X5,X3,X1] : (s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X3),s(X1,X4))),s(X2,X5))) = s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),'const.pair.,_2'(s(X1,X4),s(X2,X5)))))) )),
  inference(cnf_transformation,[],[f53])).
fof(f53,plain,(
  ! [X0,X1,X2,X3,X4,X5] : s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X3),s(X1,X4))),s(X2,X5))) = s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),'const.pair.,_2'(s(X1,X4),s(X2,X5)))))),
  inference(flattening,[],[f52])).
fof(f52,plain,(
  ! [X0,X1,X2] : ! [X3,X4,X5] : s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X3),s(X1,X4))),s(X2,X5))) = s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),'const.pair.,_2'(s(X1,X4),s(X2,X5)))))),
  inference(rectify,[],[f22])).
fof(f22,axiom,(
  ! [X6,X7,X8] : ! [X10,X13,X14] : s(X6,happ(s(fun(X8,X6),happ(s(fun(X7,fun(X8,X6)),X10),s(X7,X13))),s(X8,X14))) = s(X6,'const.pair.UNCURRY_2'(s(fun(X7,fun(X8,X6)),X10),s('type.pair.prod'(X7,X8),'const.pair.,_2'(s(X7,X13),s(X8,X14)))))),
  file('thm.pair.UNCURRY_CONG','thm.pair.UNCURRY_DEF')).
fof(f2068,plain,(
  ( ! [X4,X2,X0,X3,X1] : (s(X3,'const.pair.UNCURRY_2'(s(fun(X0,fun(X1,X3)),X4),s('type.pair.prod'(X0,X1),X2))) = s(X3,happ(s(fun(X1,X3),happ(s(fun(X0,fun(X1,X3)),X4),s(X0,sK8(X2,X1,X0)))),s(X1,sK9(X2,X1,X0))))) ) | $spl356),
  inference(cnf_transformation,[],[f2068_D])).
fof(f2068_D,plain,(
  ( ! [X4,X2,X0,X3,X1] : (s(X3,'const.pair.UNCURRY_2'(s(fun(X0,fun(X1,X3)),X4),s('type.pair.prod'(X0,X1),X2))) = s(X3,happ(s(fun(X1,X3),happ(s(fun(X0,fun(X1,X3)),X4),s(X0,sK8(X2,X1,X0)))),s(X1,sK9(X2,X1,X0))))) ) <=> ~$spl356),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl356])])).
fof(f1993,plain,(
  ( ! [X4,X2,X0,X3,X1] : (s(X3,'const.pair.UNCURRY_2'(s(fun(X0,fun(X1,X3)),X4),s('type.pair.prod'(X0,X1),X2))) = s(X3,happ(s(fun(X1,X3),happ(s(fun(X0,fun(X1,X3)),X4),s(X0,sK8(X2,X1,X0)))),s(X1,sK9(X2,X1,X0))))) ) | ($spl26 | $spl38)),
  inference(superposition,[],[f181,f175])).
fof(f175,plain,(
  ( ! [X2,X0,X1] : (s('type.pair.prod'(X0,X1),X2) = s('type.pair.prod'(X0,X1),'const.pair.,_2'(s(X0,sK8(X2,X1,X0)),s(X1,sK9(X2,X1,X0))))) ) | $spl26),
  inference(cnf_transformation,[],[f175_D])).
fof(f175_D,plain,(
  ( ! [X2,X0,X1] : (s('type.pair.prod'(X0,X1),X2) = s('type.pair.prod'(X0,X1),'const.pair.,_2'(s(X0,sK8(X2,X1,X0)),s(X1,sK9(X2,X1,X0))))) ) <=> ~$spl26),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl26])])).
fof(f118,plain,(
  ( ! [X2,X0,X1] : (s('type.pair.prod'(X0,X1),X2) = s('type.pair.prod'(X0,X1),'const.pair.,_2'(s(X0,sK8(X2,X1,X0)),s(X1,sK9(X2,X1,X0))))) )),
  inference(cnf_transformation,[],[f78])).
fof(f78,plain,(
  ! [X0,X1,X2] : s('type.pair.prod'(X0,X1),X2) = s('type.pair.prod'(X0,X1),'const.pair.,_2'(s(X0,sK8(X2,X1,X0)),s(X1,sK9(X2,X1,X0))))),
  inference(skolemisation,[status(esa),new_symbols(skolem,[sK8,sK9])],[f43])).
fof(f43,plain,(
  ! [X0,X1,X2] : ? [X3,X4] : s('type.pair.prod'(X0,X1),X2) = s('type.pair.prod'(X0,X1),'const.pair.,_2'(s(X0,X3),s(X1,X4)))),
  inference(flattening,[],[f42])).
fof(f42,plain,(
  ! [X0,X1] : ! [X2] : ? [X3,X4] : s('type.pair.prod'(X0,X1),X2) = s('type.pair.prod'(X0,X1),'const.pair.,_2'(s(X0,X3),s(X1,X4)))),
  inference(rectify,[],[f21])).
fof(f21,axiom,(
  ! [X7,X8] : ! [X13] : ? [X24,X25] : s('type.pair.prod'(X7,X8),X13) = s('type.pair.prod'(X7,X8),'const.pair.,_2'(s(X7,X24),s(X8,X25)))),
  file('thm.pair.UNCURRY_CONG','thm.pair.ABS_PAIR_THM')).
fof(f160,plain,(
  ( ! [X8,X7] : (s('type.pair.prod'(sK1,sK2),sK5) != s('type.pair.prod'(sK1,sK2),'const.pair.,_2'(s(sK1,X7),s(sK2,X8))) | s(sK0,happ(s(fun(sK2,sK0),happ(s(fun(sK1,fun(sK2,sK0)),sK3),s(sK1,X7))),s(sK2,X8))) = s(sK0,happ(s(fun(sK2,sK0),happ(s(fun(sK1,fun(sK2,sK0)),sK4),s(sK1,X7))),s(sK2,X8)))) ) | $spl2),
  inference(cnf_transformation,[],[f160_D])).
fof(f160_D,plain,(
  ( ! [X8,X7] : (s('type.pair.prod'(sK1,sK2),sK5) != s('type.pair.prod'(sK1,sK2),'const.pair.,_2'(s(sK1,X7),s(sK2,X8))) | s(sK0,happ(s(fun(sK2,sK0),happ(s(fun(sK1,fun(sK2,sK0)),sK3),s(sK1,X7))),s(sK2,X8))) = s(sK0,happ(s(fun(sK2,sK0),happ(s(fun(sK1,fun(sK2,sK0)),sK4),s(sK1,X7))),s(sK2,X8)))) ) <=> ~$spl2),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl2])])).
fof(f89,plain,(
  ( ! [X8,X7] : (s(sK0,happ(s(fun(sK2,sK0),happ(s(fun(sK1,fun(sK2,sK0)),sK3),s(sK1,X7))),s(sK2,X8))) = s(sK0,happ(s(fun(sK2,sK0),happ(s(fun(sK1,fun(sK2,sK0)),sK4),s(sK1,X7))),s(sK2,X8))) | s('type.pair.prod'(sK1,sK2),sK5) != s('type.pair.prod'(sK1,sK2),'const.pair.,_2'(s(sK1,X7),s(sK2,X8)))) )),
  inference(cnf_transformation,[],[f64])).
fof(f64,plain,(
  s('type.pair.prod'(sK1,sK2),sK5) = s('type.pair.prod'(sK1,sK2),sK6) & ! [X7,X8] : (s('type.pair.prod'(sK1,sK2),sK5) != s('type.pair.prod'(sK1,sK2),'const.pair.,_2'(s(sK1,X7),s(sK2,X8))) | s(sK0,happ(s(fun(sK2,sK0),happ(s(fun(sK1,fun(sK2,sK0)),sK3),s(sK1,X7))),s(sK2,X8))) = s(sK0,happ(s(fun(sK2,sK0),happ(s(fun(sK1,fun(sK2,sK0)),sK4),s(sK1,X7))),s(sK2,X8)))) & s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK3),s('type.pair.prod'(sK1,sK2),sK5))) != s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK4),s('type.pair.prod'(sK1,sK2),sK6)))),
  inference(skolemisation,[status(esa),new_symbols(skolem,[sK0,sK1,sK2,sK3,sK4,sK5,sK6])],[f56])).
fof(f56,plain,(
  ? [X0,X1,X2,X3,X4,X5,X6] : (s('type.pair.prod'(X1,X2),X5) = s('type.pair.prod'(X1,X2),X6) & ! [X7,X8] : (s('type.pair.prod'(X1,X2),X5) != s('type.pair.prod'(X1,X2),'const.pair.,_2'(s(X1,X7),s(X2,X8))) | s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X3),s(X1,X7))),s(X2,X8))) = s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X4),s(X1,X7))),s(X2,X8)))) & s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),X5))) != s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X4),s('type.pair.prod'(X1,X2),X6))))),
  inference(flattening,[],[f55])).
fof(f55,plain,(
  ? [X0,X1,X2,X3,X4,X5,X6] : ((s('type.pair.prod'(X1,X2),X5) = s('type.pair.prod'(X1,X2),X6) & ! [X7,X8] : (s('type.pair.prod'(X1,X2),X5) != s('type.pair.prod'(X1,X2),'const.pair.,_2'(s(X1,X7),s(X2,X8))) | s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X3),s(X1,X7))),s(X2,X8))) = s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X4),s(X1,X7))),s(X2,X8))))) & s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),X5))) != s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X4),s('type.pair.prod'(X1,X2),X6))))),
  inference(ennf_transformation,[],[f25])).
fof(f25,plain,(
  ~! [X0,X1,X2,X3,X4,X5,X6] : ((s('type.pair.prod'(X1,X2),X5) = s('type.pair.prod'(X1,X2),X6) & ! [X7,X8] : (s('type.pair.prod'(X1,X2),X5) = s('type.pair.prod'(X1,X2),'const.pair.,_2'(s(X1,X7),s(X2,X8))) => s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X3),s(X1,X7))),s(X2,X8))) = s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X4),s(X1,X7))),s(X2,X8))))) => s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),X5))) = s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X4),s('type.pair.prod'(X1,X2),X6))))),
  inference(flattening,[],[f24])).
fof(f24,plain,(
  ~! [X0,X1,X2] : ! [X3,X4,X5,X6] : ((s('type.pair.prod'(X1,X2),X5) = s('type.pair.prod'(X1,X2),X6) & ! [X7,X8] : (s('type.pair.prod'(X1,X2),X5) = s('type.pair.prod'(X1,X2),'const.pair.,_2'(s(X1,X7),s(X2,X8))) => s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X3),s(X1,X7))),s(X2,X8))) = s(X0,happ(s(fun(X2,X0),happ(s(fun(X1,fun(X2,X0)),X4),s(X1,X7))),s(X2,X8))))) => s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X3),s('type.pair.prod'(X1,X2),X5))) = s(X0,'const.pair.UNCURRY_2'(s(fun(X1,fun(X2,X0)),X4),s('type.pair.prod'(X1,X2),X6))))),
  inference(rectify,[],[f6])).
fof(f6,negated_conjecture,(
  ~! [X6,X7,X8] : ! [X9,X10,X11,X12] : ((s('type.pair.prod'(X7,X8),X11) = s('type.pair.prod'(X7,X8),X12) & ! [X13,X14] : (s('type.pair.prod'(X7,X8),X11) = s('type.pair.prod'(X7,X8),'const.pair.,_2'(s(X7,X13),s(X8,X14))) => s(X6,happ(s(fun(X8,X6),happ(s(fun(X7,fun(X8,X6)),X9),s(X7,X13))),s(X8,X14))) = s(X6,happ(s(fun(X8,X6),happ(s(fun(X7,fun(X8,X6)),X10),s(X7,X13))),s(X8,X14))))) => s(X6,'const.pair.UNCURRY_2'(s(fun(X7,fun(X8,X6)),X9),s('type.pair.prod'(X7,X8),X11))) = s(X6,'const.pair.UNCURRY_2'(s(fun(X7,fun(X8,X6)),X10),s('type.pair.prod'(X7,X8),X12))))),
  inference(negated_conjecture,[],[f5])).
fof(f5,conjecture,(
  ! [X6,X7,X8] : ! [X9,X10,X11,X12] : ((s('type.pair.prod'(X7,X8),X11) = s('type.pair.prod'(X7,X8),X12) & ! [X13,X14] : (s('type.pair.prod'(X7,X8),X11) = s('type.pair.prod'(X7,X8),'const.pair.,_2'(s(X7,X13),s(X8,X14))) => s(X6,happ(s(fun(X8,X6),happ(s(fun(X7,fun(X8,X6)),X9),s(X7,X13))),s(X8,X14))) = s(X6,happ(s(fun(X8,X6),happ(s(fun(X7,fun(X8,X6)),X10),s(X7,X13))),s(X8,X14))))) => s(X6,'const.pair.UNCURRY_2'(s(fun(X7,fun(X8,X6)),X9),s('type.pair.prod'(X7,X8),X11))) = s(X6,'const.pair.UNCURRY_2'(s(fun(X7,fun(X8,X6)),X10),s('type.pair.prod'(X7,X8),X12))))),
  file('thm.pair.UNCURRY_CONG','thm.pair.UNCURRY_CONG')).
fof(f579,plain,(
  ( ! [X0] : (s(sK0,happ(s(fun(sK2,sK0),happ(s(fun(sK1,fun(sK2,sK0)),sK3),s(sK1,sK8(X0,sK2,sK1)))),s(sK2,sK9(X0,sK2,sK1)))) = s(sK0,happ(s(fun(sK2,sK0),happ(s(fun(sK1,fun(sK2,sK0)),sK4),s(sK1,sK8(X0,sK2,sK1)))),s(sK2,sK9(X0,sK2,sK1)))) | s('type.pair.prod'(sK1,sK2),sK5) != s('type.pair.prod'(sK1,sK2),X0)) ) | $spl100),
  inference(cnf_transformation,[],[f579_D])).
fof(f579_D,plain,(
  ( ! [X0] : (s(sK0,happ(s(fun(sK2,sK0),happ(s(fun(sK1,fun(sK2,sK0)),sK3),s(sK1,sK8(X0,sK2,sK1)))),s(sK2,sK9(X0,sK2,sK1)))) = s(sK0,happ(s(fun(sK2,sK0),happ(s(fun(sK1,fun(sK2,sK0)),sK4),s(sK1,sK8(X0,sK2,sK1)))),s(sK2,sK9(X0,sK2,sK1)))) | s('type.pair.prod'(sK1,sK2),sK5) != s('type.pair.prod'(sK1,sK2),X0)) ) <=> ~$spl100),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl100])])).
fof(f572,plain,(
  ( ! [X0] : (s('type.pair.prod'(sK1,sK2),sK5) != s('type.pair.prod'(sK1,sK2),X0) | s(sK0,happ(s(fun(sK2,sK0),happ(s(fun(sK1,fun(sK2,sK0)),sK3),s(sK1,sK8(X0,sK2,sK1)))),s(sK2,sK9(X0,sK2,sK1)))) = s(sK0,happ(s(fun(sK2,sK0),happ(s(fun(sK1,fun(sK2,sK0)),sK4),s(sK1,sK8(X0,sK2,sK1)))),s(sK2,sK9(X0,sK2,sK1))))) ) | ($spl2 | $spl26)),
  inference(superposition,[],[f160,f175])).
fof(f2115,plain,(
  ( ! [X0] : (s('type.pair.prod'(sK1,sK2),sK5) != s('type.pair.prod'(sK1,sK2),X0) | s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK3),s('type.pair.prod'(sK1,sK2),X0))) = s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK4),s('type.pair.prod'(sK1,sK2),X0)))) ) | $spl410),
  inference(cnf_transformation,[],[f2115_D])).
fof(f2115_D,plain,(
  ( ! [X0] : (s('type.pair.prod'(sK1,sK2),sK5) != s('type.pair.prod'(sK1,sK2),X0) | s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK3),s('type.pair.prod'(sK1,sK2),X0))) = s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK4),s('type.pair.prod'(sK1,sK2),X0)))) ) <=> ~$spl410),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl410])])).
fof(f2114,plain,(
  ( ! [X0] : (s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK3),s('type.pair.prod'(sK1,sK2),X0))) = s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK4),s('type.pair.prod'(sK1,sK2),X0))) | s('type.pair.prod'(sK1,sK2),sK5) != s('type.pair.prod'(sK1,sK2),X0)) ) | ($spl100 | $spl356)),
  inference(forward_demodulation,[],[f2106,f2068])).
fof(f2106,plain,(
  ( ! [X0] : (s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK4),s('type.pair.prod'(sK1,sK2),X0))) = s(sK0,happ(s(fun(sK2,sK0),happ(s(fun(sK1,fun(sK2,sK0)),sK3),s(sK1,sK8(X0,sK2,sK1)))),s(sK2,sK9(X0,sK2,sK1)))) | s('type.pair.prod'(sK1,sK2),sK5) != s('type.pair.prod'(sK1,sK2),X0)) ) | ($spl100 | $spl356)),
  inference(backward_demodulation,[],[f2068,f579])).
fof(f159,plain,(
  s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK3),s('type.pair.prod'(sK1,sK2),sK5))) != s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK4),s('type.pair.prod'(sK1,sK2),sK6))) | $spl1),
  inference(cnf_transformation,[],[f159_D])).
fof(f159_D,plain,(
  s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK3),s('type.pair.prod'(sK1,sK2),sK5))) != s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK4),s('type.pair.prod'(sK1,sK2),sK6))) <=> ~$spl1),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl1])])).
fof(f90,plain,(
  s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK3),s('type.pair.prod'(sK1,sK2),sK5))) != s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK4),s('type.pair.prod'(sK1,sK2),sK6)))),
  inference(cnf_transformation,[],[f64])).
fof(f185,plain,(
  s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK3),s('type.pair.prod'(sK1,sK2),sK5))) != s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK4),s('type.pair.prod'(sK1,sK2),sK5))) | $spl43),
  inference(cnf_transformation,[],[f185_D])).
fof(f185_D,plain,(
  s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK3),s('type.pair.prod'(sK1,sK2),sK5))) != s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK4),s('type.pair.prod'(sK1,sK2),sK5))) <=> ~$spl43),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl43])])).
fof(f183,plain,(
  s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK3),s('type.pair.prod'(sK1,sK2),sK5))) != s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK4),s('type.pair.prod'(sK1,sK2),sK5))) | ($spl1 | $spl4)),
  inference(forward_demodulation,[],[f159,f162])).
fof(f162,plain,(
  s('type.pair.prod'(sK1,sK2),sK5) = s('type.pair.prod'(sK1,sK2),sK6) | $spl4),
  inference(cnf_transformation,[],[f162_D])).
fof(f162_D,plain,(
  s('type.pair.prod'(sK1,sK2),sK5) = s('type.pair.prod'(sK1,sK2),sK6) <=> ~$spl4),
  introduced(sat_splitting_component,[new_symbols(naming,[$spl4])])).
fof(f88,plain,(
  s('type.pair.prod'(sK1,sK2),sK5) = s('type.pair.prod'(sK1,sK2),sK6)),
  inference(cnf_transformation,[],[f64])).
fof(f2125,plain,(
  $false | ($spl4 | $spl43 | $spl410)),
  inference(subsumption_resolution,[],[f2124,f185])).
fof(f2124,plain,(
  s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK3),s('type.pair.prod'(sK1,sK2),sK5))) = s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK4),s('type.pair.prod'(sK1,sK2),sK5))) | ($spl4 | $spl410)),
  inference(forward_demodulation,[],[f2123,f162])).
fof(f2123,plain,(
  s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK3),s('type.pair.prod'(sK1,sK2),sK6))) = s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK4),s('type.pair.prod'(sK1,sK2),sK6))) | ($spl4 | $spl410)),
  inference(trivial_inequality_removal,[],[f2116])).
fof(f2116,plain,(
  s('type.pair.prod'(sK1,sK2),sK5) != s('type.pair.prod'(sK1,sK2),sK5) | s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK3),s('type.pair.prod'(sK1,sK2),sK6))) = s(sK0,'const.pair.UNCURRY_2'(s(fun(sK1,fun(sK2,sK0)),sK4),s('type.pair.prod'(sK1,sK2),sK6))) | ($spl4 | $spl410)),
  inference(superposition,[],[f2115,f162])).
% SZS output end Proof for thm.pair
% ------------------------------
% Version: Vampire 4.0 CASC-25 Entry
% Termination reason: Refutation

% Active clauses: 45
% Passive clauses: 208
% Generated clauses: 2010
% Final active clauses: 38
% Final passive clauses: 151
% Input formulas: 22
% Initial clauses: 57
% 
% Duplicate literals: 132
% Trivial inequalities: 51
% Fw subsumption resolutions: 78
% Fw demodulations: 141
% Bw demodulations: 13
% Condensations: 232
% 
% Simple tautologies: 87
% Equational tautologies: 21
% Forward subsumptions: 666
% 
% Binary resolution: 17
% Forward superposition: 523
% Backward superposition: 449
% Self superposition: 47
% Equality factoring: 40
% Equality resolution: 14
% 
% Split clauses: 6
% Split components: 12
% SAT solver clauses: 424
% SAT solver unit clauses: 41
% SAT solver binary clauses: 37
% SAT solver learnt clauses: 1
% 
% Sat splits: 6
% Sat splitting refutations: 6
% 
% TWLsolver clauses: 422
% TWLsolver calls for satisfiability: 222
% 
% Memory used [KB]: 3326
% Time elapsed: 0.096 s
% ------------------------------
% ------------------------------
% Success in time 0.71 s
